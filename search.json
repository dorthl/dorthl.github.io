[{"title":".NET运行时中的“Stack Walking”","url":"/archives/b/","content":"\nCLR大量使用了称为堆栈移动（或堆栈爬网）的技术。这涉及到迭代特定线程的调用帧序列，从最新的（线程的当前功能）向下回到栈的底部。\n\n运行时将堆栈遍历用于多种目的：\n\n+ 运行时在垃圾回收期间遍历所有线程的堆栈，查找托管根（在托管方法的框架中保存对象引用的局部变量，需要将这些引用报告给GC，以使对象保持活动状态，并可能在GC决定时跟踪其移动压缩堆）。\n+ 在某些平台上，堆栈处理程序用于异常处理（在第一遍中查找处理程序，在第二遍中展开堆栈）。\n+ 生成托管堆栈跟踪时，调试器将使用该功能。\n+ 各种其他方法（通常是那些与某些公共托管API接近的方法）执行堆栈遍历以获取有关其调用者的信息（例如该调用者的方法，类或程序集）。\n\n## CLR在哪里使用“Stack Walking”？\n\n在深入探讨“内部”之前，让我们看一下运行时在何处利用“堆栈遍历”，以下是完整列表（自.NET Core CLR'Release 2.2'起）。所有这些示例最终都在这里调用该Thread::StackWalkFrames(..)方法，并提供了一个callback在API遇到堆栈的新部分时触发的方法（有关更多信息，请参见下面的“如何使用它”）。\n\n#### 常见情况\n+ 垃圾收集（GC）\n    - ScanStackRoots(..)\n+ 异常处理（unwinding）\n    - x86-UnwindFrames(..)\n    - x64-ResetThreadAbortState(..)\n+ 异常处理（resumption）：\n    - ExceptionTracker::FindNonvolatileRegisterPointers(..) \n    - ExceptionTracker::RareFindParentStackFrame(..)\n+ 线程数：\n    - Thread::IsRunningIn(..)（AppDomain）\n    - Thread::DetectHandleILStubsForDebugger(..) \n+ 线程暂停：\n    - Thread::IsExecutingWithinCer()（“强制执行区域”）\n    - Thread::HandledJITCase(..)\n\n#### 调试/诊断\n\n+ 调试器\n    - DebuggerWalkStack(..)\n    - DebuggerWalkStackProc() 从调用DebuggerWalkStack(..)\n+ 托管API（例如 System.Diagnostics.StackTrace）\n\n    - 经由托管代码的调用InternalCall（C＃）DebugStackTrace::GetStackFramesInternal(..)（C ++）\n    - 在DebugStackTrace::GetStackFramesHelper(..) 结束之前\n+ DAC（通过SOS） -扫描GC“根”\n    - DacStackReferenceWalker::WalkStack<..>(..)\n+ 分析API\n    - ProfToEEInterfaceImpl::ProfilerStackWalkFramesWrapper(..)\n+ 事件管道（诊断）\n    - EventPipe::WalkManagedStackForThread(..)\n+ CLR打印堆栈跟踪（到控制台/日志，仅DEBUG构建）\n    - PrintStackTrace()\n\n#### 间接调用场景\n+ 反射\n    - RuntimeMethodHandle::GetCurrentMethod(..) 这里（回调）\n+ 应用程序（App）域\n    - SystemDomain::GetCallersMethod(..)（GetCallersType(..)和GetCallersModule(..)）\n    - SystemDomain::GetCallersModule(..) 这里（回调）\n+ “代码投放”\n    - CheckStacksAndPitch()\n+ 可扩展类工厂（System.Runtime.InteropServices.ExtensibleClassFactory）\n    - RegisterObjectCreationCallback(..) \n+ 堆栈采样器（未使用？）\n    - StackSampler::ThreadProc()\n\n## 堆栈抓取标记\n\n上述情况之一值得仔细研究，但首先，为什么要使用coreclr / issues /＃21629（注释）中的“堆栈爬网标记” ：\n\n> 不幸的是，在netstandard2.0推送过程中添加了很多传统API，它们的行为取决于调用者。调用者基本上作为隐式参数传递给API。这些StackCrawlMark中的大多数都在那里支持这些API。\n\n因此，我们可以看到CLR本身内的多个功能需要了解其调用者。为了进一步了解这一点，让我们看一个例子GetType(string typeName)。这是从外部可见方法一直到完成工作的流程，请注意StackCrawlMark实例是如何传递的：\n\n+ Type::GetType(string typeName) （创建StackCrawlMark.LookForMyCaller）\n+ RuntimeType::GetType(.., ref StackCrawlMark stackMark) \n+ RuntimeType::GetTypeByName(.., ref StackCrawlMark stackMark, ..) \n+ extern void GetTypeByName(.., ref StackCrawlMark stackMark, ..) 定义（调用本地代码，即[DllImport(JitHelpers.QCall, ..)]）\n+ RuntimeTypeHandle::GetTypeByName(.., QCall::StackCrawlMarkHandle pStackMark, ..) \n+ TypeHandle TypeName::GetTypeManaged(.., StackCrawlMark* pStackMark, ..) \n+ TypeHandle TypeName::GetTypeWorker(.. , StackCrawlMark* pStackMark, ..) \n+ SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark,..) \n+ SystemDomain::GetCallersModule(StackCrawlMark* stackMark, ..) \n+ SystemDomain::CallersMethodCallbackWithStackMark(..)\n\n另外，JIT（通过VM）还必须确保所有相关方法在调用堆栈中都可用，即它们不能被删除：\n\n+ 防止内联CEEInfo::canInline(..)\n+ 防止通过“尾部呼叫”删除CEEInfo::canTailCall(..)\n\n但是，该StackCrawlMark功能目前正在清理中，因此将来可能会有所不同：\n+ 从任务中删除NoInlining / StackCrawlMarks\n+ 从GetSatelliteAssembly删除堆栈标记\n+ 删除RtFieldInfo中不必要的StackCrawlMarks\n+ 避免在调用堆栈中不必要地传递堆栈爬网标记（如上所示示例！）\n\n## 异常处理\n\n大多数.NET开发人员都会在处理异常时碰到“堆栈跟踪”。我原本打算在这里也描述“异常处理”，但是后来我打开了/src/vm/exceptionhandling.cpp，发现其中包含7,000行以上的代码！因此，我决定可以等待将来的帖子。\n\n但是，如果您想了解有关“内部人员”的更多信息，我真的建议克里斯·布鲁姆（Chris Brumme）发表“异常模型（Exception Model）（2003）”，该主题是该主题的权威指南（另请参见他的Channel9视频），并且与往常一样，“ BotR”一章“每个（运行时）开发人员都需要了解的有关运行时异常的知识非常值得一读。\n\n另外，我建议您看一下“内部异常”演讲中的幻灯片，以及相关的.NET Inside Out Part 2 —亚当·弗曼尼克（Adam Furmanek）编写的C＃中的异常处理和重新抛出。\n\n## “堆栈漫游” API\n\n现在，我们已经看到了在那里它的使用，让我们来看看“栈行走” API本身。首先，如何使用？\n\n### 如何使用它\n\n值得指出的是，从C＃/ F＃/ VB.NET代码访问它的唯一方法是通过StackTrace 类，只有运行时本身可以Thread::StackWalkFrames(..)直接调用。运行时中最简单的用法是EventPipe::WalkManagedStackForThread(..)（请参阅此处），如下所示。如您所见，在这种情况下ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS，指定相关标志很简单，然后提供回调，该回调在EventPipe类中是StackWalkCallback方法\n\n``` C++\nbool EventPipe::WalkManagedStackForThread(Thread *pThread, StackContents &stackContents)\n{\n    CONTRACTL\n    {\n        NOTHROW;\n        GC_NOTRIGGER;\n        MODE_ANY;\n        PRECONDITION(pThread != NULL);\n    }\n    CONTRACTL_END;\n​\n    // Calling into StackWalkFrames in preemptive mode violates the host contract,\n    // but this contract is not used on CoreCLR.\n    CONTRACT_VIOLATION( HostViolation );\n​\n    stackContents.Reset();\n​\n    StackWalkAction swaRet = pThread->StackWalkFrames(\n        (PSTACKWALKFRAMESCALLBACK) &StackWalkCallback,\n        &stackContents,\n        ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS);\n​\n    return ((swaRet == SWA_DONE) || (swaRet == SWA_CONTINUE));\n}\n```\n\nStackWalkFrame(..)然后，该函数会在触发如下所示的回调之前进行实际遍历堆栈的繁重工作。在这种情况下，它仅记录“指令指针”（IP / CP）和“托管功能”，这是MethodDesc通过pCf->GetFunction()调用获得的实例：\n\n``` C++\nStackWalkAction EventPipe::StackWalkCallback(CrawlFrame *pCf, StackContents *pData)\n{\n    CONTRACTL\n    {\n        NOTHROW;\n        GC_NOTRIGGER;\n        MODE_ANY;\n        PRECONDITION(pCf != NULL);\n        PRECONDITION(pData != NULL);\n    }\n    CONTRACTL_END;\n​\n    // Get the IP.\n    UINT_PTR controlPC = (UINT_PTR)pCf->GetRegisterSet()->ControlPC;\n    if (controlPC == 0)\n    {\n        if (pData->GetLength() == 0)\n        {\n            // This happens for pinvoke stubs on the top of the stack.\n            return SWA_CONTINUE;\n        }\n    }\n​\n    _ASSERTE(controlPC != 0);\n​\n    // Add the IP to the captured stack.\n    pData->Append(controlPC, pCf->GetFunction());\n​\n    // Continue the stack walk.\n    return SWA_CONTINUE;\n}\n```\n\n### 这个怎么运作\n\n现在到最有趣的部分，如何运行时实际上遍历了堆栈。好吧，首先让我们从“ BotR”页面了解堆栈的外观：\n\n![Stack Description from BotR](../../static/images/17af7fd01c668a3fffbdebf1713d5c065bc765dfcf431c70ee905c4835186046.png)\n\n要注意的主要事情是.NET“堆栈”可以包含3种类型的方法：\n\n+ 托管-表示从C＃/ F＃/ VB.NET开始的代码，已转换为IL，然后最终由“ JIT编译器”编译为本机代码。\n+ 非托管-在运行时之外存在的完全本机代码，即运行时调用的OS函数或通过调用的用户函数P/Invoke。运行时只关心过渡到或超出常规的非托管代码，是不关心其中的堆栈帧。\n+ 运行时托管-仍是本机代码，但这有所不同，因为运行时案例更多关于此代码。例如，基本类库中有很多部分使用InternalCall方法，有关更多信息，请参见后面的“帮助器方法”框架部分。\n\n因此，“堆栈遍历”在进行过程中必须处理这些不同的情况。现在让我们看一下从入口点方法开始的“代码流” StackWalkFrames(..)：\n\n+ Thread::StackWalkFrames(..) 这里\n+ 入口点功能，通过这些标志可以控制“栈游走”的类型\n+ Thread::StackWalkFramesEx(..) 这里\n+ StackFrameIterator通过调用here设置的worker函数StackFrameIterator::Init(..)\n+ StackFrameIterator::Next() 在这里，然后放手给初级工人的方法+\n+ StackFrameIterator::NextRaw() 在这里，做5件事情：\n    - EEJitManager::JitCodeToMethodInfo(..) 在这里，它使用了一个看起来很酷的数据结构，称为“半字节映射”\n    - NativeImageJitManager::JitCodeToMethodInfo(..)\n    - ReadyToRunJitManager::JitCodeToMethodInfo(..)\n    - x64-Thread::VirtualUnwindCallFrame(..) 在这里，然后VirtualUnwindNonLeafCallFrame(..) 在这里或VirtualUnwindLeafCallFrame(..) 这里打电话。所有这些函数都利用Windows API函数 RtlLookupFunctionEntry(..)进行实际的展开。\n    - x86-::UnwindStackFrame(..) 在这里，依次UnwindEpilog(..) 在这里和UnwindEspFrame(..) 这里打电话。不同于x64，在x86所有CRL代码中，所有的“堆栈展开”都是手动完成的。\n        - CheckForSkippedFrames(..) 在这里，处理可能已在托管堆栈帧中分配的帧（例如，内联的p / invoke调用）。\n        - UnwindStackFrame(..) 在这里，依次致电：\n        - PostProcessingForManagedFrames(..) 在这里，确定堆栈遍历实际上是否在托管方法内，而不是在本机框架内。\n        - ProcessIp(..) 这是根据当前指令指针（IP）查找当前托管方法（如果有）的工作。它通过调用到 这里，然后以以下其中一种方式结束： EECodeInfo::Init(..)\n        - ProcessCurrentFrame(..) 在这里，做一些最后的整理和整理。\n+ CrawlFrame::GotoNextFrame() 这里\n    - 在pFrame->Next() 这里依次调用以遍历驱动“堆栈遍历”的框架的“链接列表”（稍后在这些“框架”中详细介绍）\n+ StackFrameIterator::Filter() 这里\n    - 本质上，这是一个处理所有不同框架状态并决定是否应继续执行“堆栈遍历”的巨大switch声明。\n\n时，它得到一个有效的帧它触发回调在Thread::MakeStackwalkerCallback(..) 这里和在经过一个指向当前CrawlFrame类这里定义，这暴露的方法，如IsFrameless()，GetFunction()和GetThisPointer()。该CrawlFrame实际上代表2分的情况，基于当前的IP：\n\n+ 由此处定义的Frame类表示的本机代码，我们将在稍后讨论。\n+ 托管代码，从技术上讲就是“本地代码”的“托管代码”，因此更准确地说是托管堆栈框架。在这种情况下，将提供此处定义的MethodDesc类，您可以在相应的BotR章中阅读有关此关键CLR数据结构的更多信息。\n\n### 看到它在行动\n\n幸运的是，我们能够在CLR（COMPLUS_LogEnable，COMPLUS_LogToFile＆COMPLUS_LogFacility）的调试版本中打开一些不错的诊断程序。有了适当的代码后，给出如下C＃代码：\n\n``` C#\ninternal class Program {\n    private static void Main() {\n        MethodA();\n    }\n​\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodA() {\n        MethodB();\n    }\n    \n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodB() {\n        MethodC();\n    }\n    \n    [MethodImpl(MethodImplOptions.NoInlining)]\n    private void MethodC() {\n        var stackTrace = new StackTrace(fNeedFileInfo: true);\n        Console.WriteLine(stackTrace.ToString());\n    }\n}\n```\n我们得到如下所示的输出，您可以在其中看到“堆栈行走”过程。它开始于InitializeSourceInfo和CaptureStackTrace它们内部的方法StackTrace类（见这里），向上移动堆栈前MethodC- > MethodB- > MethodA，最后停止在Main函数。在实际展开之前，它会执行“ FILTER”和“ CONSIDER”步骤（“完成……结束”）：\n\n``` log\nTID 4740: STACKWALK    starting with partial context\nTID 4740: STACKWALK: [000] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [001] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [001] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [002] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 \nTID 4740: STACKWALK    LazyMachState::unwindLazyState(ip:00007FFD7439C45C,sp:000000029977C338)\nTID 4740: STACKWALK: [002] CALLBACK: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 \nTID 4740: STACKWALK    HelperMethodFrame::UpdateRegDisplay cached ip:00007FFD72FE9258, sp:000000029977D300\nTID 4740: STACKWALK: [003] CONSIDER: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo \nTID 4740: STACKWALK: [003] CALLBACK: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo \nTID 4740: STACKWALK: [004] about to unwind for 'InitializeSourceInfo', SP: 00000002`9977d300 , IP: 00007ffd`72fe9258 \nTID 4740: STACKWALK: [004] finished unwind for 'InitializeSourceInfo', SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 \nTID 4740: STACKWALK: [004] CONSIDER: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace \nTID 4740: STACKWALK: [004] CALLBACK: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace \nTID 4740: STACKWALK: [005] about to unwind for 'CaptureStackTrace', SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 \nTID 4740: STACKWALK: [005] finished unwind for 'CaptureStackTrace', SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 \nTID 4740: STACKWALK: [005] CONSIDER: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor \nTID 4740: STACKWALK: [005] CALLBACK: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor \nTID 4740: STACKWALK: [006] about to unwind for '.ctor', SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 \nTID 4740: STACKWALK: [006] finished unwind for '.ctor', SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 \nTID 4740: STACKWALK: [006] CONSIDER: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC \nTID 4740: STACKWALK: [006] CALLBACK: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC \nTID 4740: STACKWALK: [007] about to unwind for 'MethodC', SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 \nTID 4740: STACKWALK: [007] finished unwind for 'MethodC', SP: 00000002`9977d630 , IP: 00007ffd`14c62066 \nTID 4740: STACKWALK: [007] CONSIDER: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB \nTID 4740: STACKWALK: [007] CALLBACK: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB \nTID 4740: STACKWALK: [008] about to unwind for 'MethodB', SP: 00000002`9977d630 , IP: 00007ffd`14c62066 \nTID 4740: STACKWALK: [008] finished unwind for 'MethodB', SP: 00000002`9977d660 , IP: 00007ffd`14c62016 \nTID 4740: STACKWALK: [008] CONSIDER: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA \nTID 4740: STACKWALK: [008] CALLBACK: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA \nTID 4740: STACKWALK: [009] about to unwind for 'MethodA', SP: 00000002`9977d660 , IP: 00007ffd`14c62016 \nTID 4740: STACKWALK: [009] finished unwind for 'MethodA', SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 \nTID 4740: STACKWALK: [009] CONSIDER: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main \nTID 4740: STACKWALK: [009] CALLBACK: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main \nTID 4740: STACKWALK: [00a] about to unwind for 'Main', SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 \nTID 4740: STACKWALK: [00a] finished unwind for 'Main', SP: 00000002`9977d6d0 , IP: 00007ffd`742f9073 \nTID 4740: STACKWALK: [00a] FILTER  : NATIVE   : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0 \nTID 4740: STACKWALK: [00b] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [00b] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [00c] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: [00c] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 \nTID 4740: STACKWALK: SWA_DONE: reached the end of the stack\n```\n\n要了解更多信息，可以在\\vm\\stackwalk.cpp中搜索这些诊断消息，例如在Thread::DebugLogStackWalkInfo(..) 此处\n\n## 展开“本地”代码\n\n如这篇出色的文章所述：\n\n> 从根本上讲，有两种主要方法可以在ABI（应用程序二进制接口）中实现异常传播：\n> + “动态注册”，在每个激活记录中带有框架指针，并组织为一个链表。这使得堆栈快速展开，但以必须在调用其他函数的每个函数中设置帧指针为代价。这也更容易实现。\n> + “表驱动”，其中编译器和汇编器在程序代码旁边创建数据结构，以指示哪些代码地址对应于哪些激活记录大小。在例如GNU工具链中，这称为“呼叫帧信息”（CFI）数据。生成异常时，将加载此表中的数据以确定如何展开。这使得异常传播较慢，但一般情况下较快。\n\n事实证明，.NET使用“表驱动”方法，原因在“ BotR”中进行了解释：\n\n> 框架的确切定义因平台而异，并且在许多平台上，并没有硬性定义所有功能都遵循的框架格式（x86就是一个示例）。相反，编译器通常可以自由地优化帧的确切格式。在此类系统上，无法保证stackwalk将返回100％正确或完整的结果（出于调试目的，使用诸如pdbs之类的调试符号来填补空白，以便调试器可以生成更准确的堆栈跟踪）。\n\n> 对于CLR，这不是问题，因为我们不需要完全通用的堆栈遍历。取而代之的是，我们只对那些受管理的框架（即代表托管方法）感兴趣，或者在某种程度上，这些框架来自用于实现部分运行时本身的非托管代码。特别是，除了说明此类帧在何处过渡到运行时本身或从运行时本身过渡（即我们关心的帧类型之一）的位置外，不能保证第三方非托管帧的保真度。\n\n## 镜框\n\n为了启用本机代码的“展开”或更严格地实现本机代码的“进入”和“退出”转换，CLR使用的机制Frames，该机制在此处的源代码中定义。这些框架排列成层次结构Frame，每种情况都有一种类型，有关这些个体的更多信息，Frames请在此处查看出色的源代码注释。\n\n+ 框架（抽象/基类）\n    - ComMethodFrame\n    - UMThkCallFrame\n    - ComPrestubMethodFrame\n    - StubHelperFrame\n    - SecureDelegateFrame\n    - FramedMethodFrame\n    - 组播帧\n    - ComPlusMethodFrame\n    - PInvokeCalliFrame\n    - PrestubMethodFrame\n    - StubDispatchFrame\n    - 外部方法框架\n    - TPMethodFrame\n    - HelperMethodFrame_1OBJ\n    - HelperMethodFrame_2OBJ\n    - HelperMethodFrame_3OBJ\n    - HelperMethodFrame_PROTECTOBJ\n    - RedirectedThreadFrame\n    - GC框架\n    - FaultingExceptionFrame\n    - HijackFrame\n    - 可恢复帧\n    - InlinedCallFrame\n    - HelperMethodFrame\n    - TransitionFrame\n    - UnmanagedToManagedFrame\n    - ContextTransitionFrame\n    - 尾叫帧\n    - ProtectByRefsFrame\n    - ProtectValueClassFrame\n    - 调试器类InitMarkFrame\n    - DebuggerSecurityCodeMarkFrame\n    - 调试器退出框架\n    - 调试器U2MCatchHandlerFrame\n    - FuncEvalFrame\n    - ExceptionFilterFrame\n\n## “帮助方法”框架\n\n但是，为了理解这一点，让我们看一种Frame称为的HelperMethodFrame（上）。当运行时的.NET代码调用C ++代码进行繁重的操作时（通常出于性能原因），将使用此功能。一个示例是，如果您Environment.GetCommandLineArgs()最终以该代码（C＃）进行调用，但请注意，它最终会调用extern标记为的方法InternalCall：\n\n``` C#\n[MethodImplAttribute(MethodImplOptions.InternalCall)]\nprivate static extern string[] GetCommandLineArgsNative();\n```\n\n这意味着，该方法的其余部分在C ++运行时实现，你可以看到方法调用是如何有线了，结束了之前SystemNative::GetCommandLineArgs 在这里其如下所示，：\n\n``` C++\nFCIMPL0(Object*, SystemNative::GetCommandLineArgs)\n{\n    FCALL_CONTRACT;\n\n    PTRARRAYREF strArray = NULL;\n\n    HELPER_METHOD_FRAME_BEGIN_RET_1(strArray); // <-- 'Helper method Frame' started here\n\n    // Error handling and setup code removed for clarity\n\n    strArray = (PTRARRAYREF) AllocateObjectArray(numArgs, g_pStringClass);\n    // Copy each argument into new Strings.\n    for(unsigned int i=0; i<numArgs; i++)\n    {\n        STRINGREF str = StringObject::NewString(argv[i]);\n        STRINGREF * destData = ((STRINGREF*)(strArray->GetDataPtr())) + i;\n        SetObjectReference((OBJECTREF*)destData, (OBJECTREF)str, strArray->GetAppDomain());\n    }\n    delete [] argv;\n\n    HELPER_METHOD_FRAME_END(); // <-- 'Helper method Frame' ended/closed here\n\n    return OBJECTREFToObject(strArray);\n}\nFCIMPLEND\n```\n\n注意：此代码大量使用了宏，有关原始代码和扩展版本（发布和调试），请参见本要点。此外，如果您想了解有关这些神秘物品FCalls（以及相关的物品QCalls）的更多信息，请参见Mscorlib和“ BotR”中的“调用运行时”。\n\n但是在代码示例中要看的主要是HELPER_METHOD_FRAME_BEGIN_RET_1()宏，最终安装了HelperMethodFrame_1OBJ类的实例。宏扩展为如下代码：\n\n``` C++\nFrameWithCookie < HelperMethodFrame_1OBJ > __helperframe(__me, Frame::FRAME_ATTR_NONE, (OBJECTREF * ) & strArray); \n{\n  __helperframe.Push(); // <-- 'Helper method Frame' pushed\n\n  Thread * CURRENT_THREAD = __helperframe.GetThread();\n  const bool CURRENT_THREAD_AVAILABLE = true;\n  (void) CURRENT_THREAD_AVAILABLE;; {\n\tException * __pUnCException = 0;\n\tFrame * __pUnCEntryFrame = ( & __helperframe);\n\tbool __fExceptionCatched = false;;\n\ttry {;\n\n\t  // Original code from SystemNative::GetCommandLineArgs goes in here\n\n\t} catch (Exception * __pException) {;\n\t  do {} while (0);\n\t  __pUnCException = __pException;\n\t  UnwindAndContinueRethrowHelperInsideCatch(__pUnCEntryFrame, __pUnCException);\n\t  __fExceptionCatched = true;;\n\t}\n\tif (__fExceptionCatched) {;\n\t  UnwindAndContinueRethrowHelperAfterCatch(__pUnCEntryFrame, __pUnCException);\n\t}\n  };\n  \n  __helperframe.Pop(); // <-- 'Helper method Frame' popped\n};\n```\n\n注意：Push()和Pop()相对_helperMethodFrame应，可用于“堆栈行走”。您还可以看到CLR放置的try/catch块，以确保将本机代码中的任何异常转换为C＃/ F＃/ VB.NET代码可以处理的托管异常。如果您有兴趣，可以在此摘要中找到完整的宏扩展。\n\n因此，总而言之，当调用本机代码时，它们Frames会被推送到“链接列表”上，而从本机代码返回时，它们会从列表中弹出。这意味着“链接列表”随时都包含所有当前或活动列表Frames。\n\n## 本机放松信息\n\n除了创建“框架”之外，CLR还确保C ++编译器为本地代码发出“展开信息”。如果我们使用DUMPBIN工具并运行，我们可以看到这一点dumpbin /UNWINDINFO coreclr.dll。我们得到以下输出SystemNative::GetCommandLineArgs(..)（之前已经看过）：\n\n```\n  0002F064 003789B0 00378B7E 004ED1D8  ?GetCommandLineArgs@SystemNative@@SAPEAVObject@@XZ (public: static class Object * __cdecl SystemNative::GetCommandLineArgs(void))\n    Unwind version: 1\n    Unwind flags: EHANDLER UHANDLER\n    Size of prologue: 0x3B\n    Count of codes: 13\n    Unwind codes:\n      29: SAVE_NONVOL, register=r12 offset=0x1C8\n      25: SAVE_NONVOL, register=rdi offset=0x1C0\n      21: SAVE_NONVOL, register=rsi offset=0x1B8\n      1D: SAVE_NONVOL, register=rbx offset=0x1B0\n      10: ALLOC_LARGE, size=0x190\n      09: PUSH_NONVOL, register=r15\n      07: PUSH_NONVOL, register=r14\n      05: PUSH_NONVOL, register=r13\n    Handler: 00148F14 __GSHandlerCheck_EH\n    EH Handler Data: 00415990\n    GS Unwind flags: EHandler UHandler\n    Cookie Offset: 00000180\n\n  0002F070 00378B7E 00378BB4 004ED26C\n    Unwind version: 1\n    Unwind flags: EHANDLER UHANDLER\n    Size of prologue: 0x0A\n    Count of codes: 2\n    Unwind codes:\n      0A: ALLOC_SMALL, size=0x20\n      06: PUSH_NONVOL, register=rbp\n    Handler: 0014978C __CxxFrameHandler3\n    EH Handler Data: 00415990\n```\n\n如果您想了解此处的更多信息，我真的建议您阅读出色的文章x64手动堆栈重建和堆栈遍历。但实质上，“展开信息”描述了方法中使用的寄存器以及该方法的堆栈数。这些信息足以告诉运行时如何在堆栈中“展开”该特定方法。\n\n## Windows和Unix之间的差异\n\n但是，更复杂的是，“本机代码展开”对“ Windows”和“ Unix”使用了不同的机制，如coreclr / issues /＃177（注释）所述：\n\n> + 用于管理代码的堆栈遍历器。JIT将生成常规的Windows样式展开信息。我们将重用当前已检入的Windows展开器代码中的调试器组件，以展开Linux / Mac上托管代码中的调用。不幸的是，这项工作需要对运行时进行更改，而这些更改目前无法在CoreCLR存储库中进行测试，因此现在很难在公开场合进行。但是我们正在努力解决这一问题，因为正如我在开始时提到的那样，我们的目标是在公众中开展大多数工作。\n> + 适用于本机代码的Stack Walker。在这里，除了其他所有内容外，我们还需要允许GC释放当前进程中任何线程的本机堆栈，直到找到托管帧为止。当前，我们正在考虑使用libunwind（http://www.nongnu.org/libunwind）释放本机调用堆栈。@janvorli做过一些原型设计/实验，似乎可以满足我们的需求。如果您有使用此库的任何经验或有任何意见/建议，请告诉我们。\n\n这还表明，对于“托管”或“本机”代码有两种不同的“展开”机制，我们将讨论“展开“ JITted”代码中的“用于托管代码的堆栈行进器”如何工作。\n\n在coreclr / issues /＃177（注释）中也有更多信息：\n\n> 我的当前工作分为两部分，正如@ sergiy-k已经提到的那样。在windows风格开卷将被用于实时编译的代码和Unix的开卷本地代码使用的libunwind的低级别unw_xxxx的功能，如unw_step等。\n\n因此，对于“本机代码”，运行时使用特定于操作系统的机制，即在Unix上使用开源的“ libunwind”库。您可以在下面的代码（从这里开始）中看到不同之处，在Windows Thread::VirtualUnwindCallFrame(..)（实现）下被调用，但是在Unix（即FEATURE_PAL）PAL_VirtualUnwind(..)（实现）上被调用：\n\n``` C++ \n#ifndef FEATURE_PAL\n    pvControlPc = Thread::VirtualUnwindCallFrame(&ctx, &nonVolRegPtrs);\n#else // !FEATURE_PAL\n    ...\n    BOOL success = PAL_VirtualUnwind(&ctx, &nonVolRegPtrs);\n    ...\n    pvControlPc = GetIP(&ctx);\n#endif // !FEATURE_PAL\n```\n\n在进一步介绍之前，这里有一些指向.NET Core CLR移植到Linux时为支持“堆栈移动”所做的工作的链接：\n\n+ [x86 / Linux]支持简单异常捕获\n+ [ARM / Linux] coreclr因libunwind＃6698中缺少DWARF功能而失败\n+ 修改Windows amd64展开器，使其在Uni…上作为固定代码展开器工作＃259\n+ 重构libunwind以在OSX上工作＃284\n+ 重新实现PAL＃308的本机异常处理\n+ 将Windows展开器代码移出debug文件夹。\n+ .NET核心依赖项（包括“ libunwind”）\n+ sos“ ClrStack”命令现在可以使用\n\n## 展开“ JITted”代码\n\n最后，我们将研究“托管代码”的情况，即以C＃/ F＃/ VB.NET开始的代码被转换为IL，然后由“ JIT编译器”编译为本地代码。这是您通常希望在“堆栈跟踪”中看到的代码，因为它是您自己编写的代码！\n\n### 来自“ JIT编译器”的帮助\n\n简而言之，发生的事情是，当代码被“ JITted”时，编译器还会发出一些额外的信息，这些信息通过在此处EECodeInfo定义的类存储。另见“开卷信息”部分中的JIT编译器< - >运行界面，注意它是如何拥有单独的章节，，和。TARGET_ARMTARGET_ARM64TARGET_X86TARGET_UNIX\n\n另外，CodeGen::genFnProlog() 这里的JIT发出一个函数“序言”，其中包含一些与“展开”相关的数据。这也imlemented在CEEJitInfo::allocUnwindInfo(..)在这一段代码，其表现不同对每个CPU架构：\n\n``` C++\n#if defined(_TARGET_X86_)\n    // Do NOTHING\n#elif defined(_TARGET_AMD64_)\n    pUnwindInfo->Flags = UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER;\n    ULONG * pPersonalityRoutine = (ULONG*)ALIGN_UP(&(pUnwindInfo->UnwindCode[pUnwindInfo->CountOfUnwindCodes]), sizeof(ULONG));\n    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();\n#elif defined(_TARGET_ARM64_)\n    *(LONG *)pUnwindInfo |= (1 << 20); // X bit\n    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, sizeof(ULONG)));\n    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();\n#elif defined(_TARGET_ARM_)\n    *(LONG *)pUnwindInfo |= (1 << 20); // X bit\n    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, sizeof(ULONG)));\n    *pPersonalityRoutine = (TADDR)ProcessCLRException - baseAddress;\n#endif\n```\n\n而且，JIT有几种Compiler::unwindXXX(..)方法，所有方法都在每个CPU的源文件中实现：\n\n+ /src/jit/unwind.cpp\n+ /src/jit/unwind arm .cpp\n+ /src/jit/unwind x86 .cpp\n+ /src/jit/unwind amd64 .cpp\n+ /src/jit/unwind arm64 .cpp\n\n幸运的是，我们可以要求JIT输出它发出的展开信息，但这仅适用于CLR的调试版本。给定一个像这样的简单方法：\n\n``` C#\nprivate void MethodA() {\n    try {\n        MethodB();\n    } catch (Exception ex) {\n        Console.WriteLine(ex.ToString());\n    }\n}\n```\n\n如果调用SET COMPlus_JitUnwindDump=MethodA，我们将获得以下输出，其中包含2个“ Unwind Info”部分，一个用于try，另一个用于该catch块：\n\n```\nUnwind Info:\n  >> Start offset   : 0x000000 (not in unwind data)\n  >>   End offset   : 0x00004e (not in unwind data)\n  Version           : 1\n  Flags             : 0x00\n  SizeOfProlog      : 0x07\n  CountOfUnwindCodes: 4\n  FrameRegister     : none (0)\n  FrameOffset       : N/A (no FrameRegister) (Value=0)\n  UnwindCodes       :\n    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 11 * 8 + 8 = 96 = 0x60\n    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)\n    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)\n    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)\nUnwind Info:\n  >> Start offset   : 0x00004e (not in unwind data)\n  >>   End offset   : 0x0000e2 (not in unwind data)\n  Version           : 1\n  Flags             : 0x00\n  SizeOfProlog      : 0x07\n  CountOfUnwindCodes: 4\n  FrameRegister     : none (0)\n  FrameOffset       : N/A (no FrameRegister) (Value=0)\n  UnwindCodes       :\n    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 = 48 = 0x30\n    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)\n    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)\n    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)\n```\n\n然后，按照上面的“如何工作”部分中的说明，在“堆栈遍历”期间查找此“展开信息” 。\n\n因此，下次您遇到“堆栈跟踪”时，请记住，要使之成为可能的工作量很大！！","tags":[".Net","程序性能",".Net源码"],"categories":["编程"]},{"title":"使用Flamegraph分析.NET启动时间","url":"/archives/a/","content":"\n# .NET运行时在启动过程中在哪里花费时间？\n\n> 翻译自 https://mattwarren.org/2020/03/03/Analysing-.NET-Runtime-Startup-with-Flamegraphs/\n\n## 代码样例\n\n在本练习中，我们仅关注程序启动期间的.NET运行时，我们确保正在运行最少数量的用户代码，因此使用以下“Hello World\"：\n\n```\nusing System;\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n            Console.WriteLine(\"Press <ENTER> to exit\");\n            Console.ReadLine();\n        }\n    }\n}\n```\n之所以添加Console.ReadLine()调用是因为我想确保在PerfView仍在收集数据的同时该过程不会退出。\n\n## 数据采集\n\nPerfView是一个非常强大的程序，但不是最用户友好的工具，因此我整理了逐步指南：\n\n+ 下载并运行最新版本的“ PerfView.exe”\n+ 单击“Run a command”或（Alt-R），然后单击“collect data while the command is running”\n+ 确保输入以下值：\n    - “Command”\n    - “Current Dir”\n+ 如果尚未选中，请勾选“ Cpu Samples ”\n+ 将“ Max Collect Sec ”设置为15秒（因为我们的“ HelloWorld”应用程序永远不会退出，因此我们需要确保PerfView在某个时刻停止收集数据）\n+ 确保已选择“ .NET Symbol Collection ”\n+ 点击运行命令\n\n![PerfView - Collection Options - annotated](../../static/images/c5ff606a305ee5a5d7cef2a98cc97ee7fe1959cb6ac5e7b77087f6f05868ddbc.png)\n\n如果随后查看该日志，则可以看到该日志正在收集数据，获取符号并最终将所有内容写到.zip文件中。完成该过程后，您应该在主UI的左侧窗格中看到新创建的文件，在这种情况下，该文件称为“ PerfViewData.etl.zip”\n\n## 数据处理\n\n拥有“ .etl.zip”文件后，双击该文件，您将看到带有所有可用数据的树状视图。现在，选择“ CPU Stacks”，将显示如下视图：\n\n![PerfView - Unresolved Symbols](../../static/images/8ea3f490fbb7e3c8da7f097acdd3dcc46e14ffb6f85eacf16c077e1ee0d0ca97.png)\n\n注意列表中有很多“？” 的字符，这意味着PerfView无法解决方法名称，因为它尚未解析运行时dll的必要符号。让我们修复：\n\n+ 打开“ CPU堆栈”\n+ 在列表中，选择“ HelloWorld ”过程（PerfView在整个计算机范围内收集数据）\n+ 在“ GroupPats ”下拉列表中，选择“ [no grouping]”\n+ 可选，将“符号路径”从默认值更改为其他值\n+ 在“按名称”标签中，按“ Ctrl + A”以选择所有行\n+ 右键单击并选择“查找符号”（或仅单击“ Alt + S”）\n\n现在，\"CPU Stacks\"视图应如下所示：\n\n![PerfView - Resolved Symbols](../../static/images/a72b381b15a76ee06490bfe124cdc823ac035f8c461b2c1f2c840e21cfd3a5b8.png)\n\n最后，我们可以获得所需的数据：\n\n+ 选择“Flame Graph”标签\n+ 将“ GroupPats ”更改为以下值之一以获得更好的火焰图：\n+ 将“ Fold％ ”更改为更高的数字，可能是3％，以消除一些悠长的线条（更高的条形，但将丢失一些细节信息）\n\n![PerfView - Flamegraph](../../static/images/818230a3c2095bc6be930df1506d17a211bf243b09562c9df905d46ae0475162.png)\n\n现在，在这一点上，我建议用PerfView数据导出为可装入一个格式https://speedscope.app 这个网站上可以生成更直观的火焰图。为此，单击File->Save View As，然后在“Save as type”框中选择“Speed Scope Format”。之后即可上传到speedscope.app 进行分析。\n\n## .NET运行时启动的分析\n\n最后，我们可以回答我们原来的问题：\n\n> .NET运行时在启动过程中在哪里花费时间？\n\n这是来自Flamegraph的数据，摘要为文本，并链接了.NET Core Runtime源代码中的相应功能：\n\n+ 整个应用-100％ -233.28ms\n+ 一切，除了helloworld!wmain- 21％\n+ helloworld!wmain- 79％ - 184.57ms\n    - coreclr!RunMain- 9.9％， - 23.12ms\n    - coreclr!RunStartupHooks- 8.1％， - 19.00ms\n    - coreclr!CorHost2::Start- 9％， - 20.98ms\n    - coreclr!CorHost2::CreateAppDomain- 10％ - 23.52ms\n    - hostpolicy!create_hostpolicy_context- 30％ - 70.92ms\n    - hostpolicy!create_coreclr- 22％ - 50.51ms\n    - hostpolicy!runapp- 20％ - 46.20ms 最终调用到Assembly::ExecuteMainMethod \n    - hostfxr!resolve_frameworks_for_app- 3.4％， - 7.89ms\n\n因此，运行时花费时间的主要位置是：\n\n+ 花了总时间的30％来启动运行时，这是通过“host policy”控制的，这主要发生在hostpolicy!create_hostpolicy_context总时间的30％中\n+ 22％的时间花费在运行时本身及其创建的初始（唯一）AppDomain的初始化上，这可以在CorHost2::Start（native）和CorHost2::CreateAppDomain（managed）中看到。\n+ 从上面开始，在我们的“ Hello World”代码示例中使用了20％的JITting并执行了该Main方法Assembly::ExecuteMainMethod。\n\n为了确认最后一点，我们可以返回PerfView并查看它产生的“ JIT统计摘要”。从主菜单的“高级组”->“ JIT统计信息”下，我们看到JITing花费了23.1 ms或9.1％的CPU总时间：\n\n![PerfView - JIT Stats for HelloWorld](../../static/images/8fb1101eca336ff59b7bf83ae254136420c5850270f954022f75aeed0004a2ec.png)\n","tags":[".Net","程序性能","PerfView","火焰图"],"categories":["编程"]}]