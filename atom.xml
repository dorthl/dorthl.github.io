<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>留声与视</title>
  <icon>https://www.nenufm.com/icon.png</icon>
  <subtitle>留声与视 个人博客 dorthl .net</subtitle>
  <link href="https://www.nenufm.com/atom.xml" rel="self"/>
  
  <link href="https://www.nenufm.com/"/>
  <updated>2021-01-12T10:05:09.923Z</updated>
  <id>https://www.nenufm.com/</id>
  
  <author>
    <name>dorthl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《进击的巨人》的全故事线</title>
    <link href="https://www.nenufm.com/archives/e/"/>
    <id>https://www.nenufm.com/archives/e/</id>
    <published>2021-01-12T09:56:09.000Z</published>
    <updated>2021-01-12T10:05:09.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《进击的巨人》的全故事线"><a href="#《进击的巨人》的全故事线" class="headerlink" title="《进击的巨人》的全故事线"></a>《进击的巨人》的全故事线</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>谨以此文纪念追随了7年的神作《进击的巨人》，虽然前面的高赞已经整理的很好了，但在这里作为知乎新人，巨人的老粉，我也来尝试做一个时间线的整理，当作对自己的一个纪念，漫画目前出到135话，情节基本都舒展开了，也没几个坑了，就等三四个月后的结局了。</p><p>本文可能会讲的比较白话文，会涉及大量的剧透，还请动画党自己斟酌，然后呢，这个整理内容的顺序从2000年前开始讲起，内容划分按照动画的内容来，其中会补充一些细节还有些许大众的，我个人的推理和猜测，这个我是会标记出来的，听说点击右上角和双击屏幕会长高的哦，兵长都说好。</p><h3 id="2000年前"><a href="#2000年前" class="headerlink" title="2000年前"></a>2000年前</h3><p>2000年前，一个名为艾尔迪亚的部落存在于这个世界的某个大陆上，和许多其他的部落一样，该部落实行奴隶制，将俘获的其他部落的战俘割掉舌头，当作自己部落的奴隶，这个部落的首领，叫初代弗里茨王（万恶之源），1900多年后他的后代是帕拉迪岛online的实际控制者，雷斯家族，而雷斯家族的某个私生女叫做希斯特里亚，是进击的巨人的男主角艾伦的同期战友，人生知己，这是后话。</p><p>弗里茨王的奴隶中，有一个小女孩，叫做尤弥尔，这个尤弥尔也是个被割了舌头的奴隶，某天，在尤弥尔正围观两个奴隶舌吻的时候，心脏还扑通通乱跳呢，就和其他奴隶一起被抓了起来，原来，围栏里有一头特立独行的猪向往自由，顺着开着的门跑了，弗里茨王很生气，要求奴隶供出到底谁把猪栏的门打开，把猪给放跑了，如果没人承认，那么所有的奴隶都要被挖掉一只眼睛（这句话比较关键），然后，十三个奴隶把手齐齐的指向了尤弥尔（13是作者的幸运数字，以后会多次出现，比如，埃尔文·史密斯团长就是调查兵团第十三任团长，还有，135话的开头，暗示了真的是尤弥尔放走了猪），于是，可怜的尤弥尔不得不承认她放走了猪，她被放逐了，弗里茨王嘲讽的说，“你，自由了。”</p><p>随后部落开始了人猎，就是尤弥尔在前面逃跑，后面的人骑着马，带着猎狗，朝她射箭，尤弥尔流出了血泪，这个时候，她发现了一个树洞，跳了进去，却不曾想里面竟然是冰冷的地下水，刺骨的冷水刺激着尤弥尔的皮肤，然后，一种神秘的史前生物靠近了她，这个神似脊柱的生物我们暂时称之为异形，后面艾伦灭世的时候变身的怪物就很像这个东西。</p><p>尤弥尔因此获得了巨人之力，后来的传说是，尤弥尔与大地恶魔做了交易，自此，尤弥尔被称作始祖尤弥尔。尤弥尔获得了巨人之力后，并没有选择复仇，或者说，她从小就被灌输了奴隶的思想，她甚至不知道复仇是一个什么概念，于是她又回到了艾尔迪亚部落，成为了一个奴隶，因为尤弥尔拥有了巨人之力，弗里茨方带领了部落迅速的开疆扩土，铺路建桥，征服了很多敌对部落，期间，弗里茨王破格赐给了尤弥尔姓氏，并和她生下了三个女儿， 玛丽亚，罗塞，希纳，也就是后来帕拉迪岛上的三道巨人之墙的名字。</p><p>在尤弥尔的帮助下，艾尔迪亚无人能敌，巨人之力在冷兵器时期就纯属是降维打击，其中臣服于它的淫威下的部落里，就有马莱，某天，马莱人假装来和弗里茨王谈判，实际上是来刺杀的，在马莱人掷出了飞茅后，尤弥尔挺身而出，替弗里茨王挡下了这致命一击，弗里茨却王丝毫不为所动，还冷冷的说，“站起来干活啊，尤弥尔，我知道这是杀不了你的。”然而尤弥尔却没有响应这个老东西的话，她真的死了。</p><blockquote><p>在这里有个推测，也许尤弥尔是自己主动求死，因为弗里茨王伤害了她的心，或者她忍受够了，也许目睹两个奴隶的接吻让她意识到了爱情是存在的，但她却没能拥有，也许是其他原因。</p></blockquote><blockquote><p>尤弥尔的死，可能是尤弥尔获得巨人之力后的第13年，所以以后的智慧巨人的继承者都只能活13年。</p></blockquote><p>在尤弥尔死后，弗里茨王仍然不放过她，他勒令他和尤弥尔的三个女儿，吞食了尤弥尔的尸体，在多年以后，尤弥尔的力量分散为了九大巨人，就是能够控制除进击的巨人之外的所有巨人，可以连接路（稍后解释）的始祖巨人（但是有条件，始祖巨人的使用者必须是弗里茨王族后人，或者始祖巨人要接触到拥有弗里茨王族血统的智慧巨人拥有者，才能触发坐标之力，坐标，就是连接路的力量），单挑王，能够凭空制造武器的战锤巨人，自由的，不受控制的进击的巨人，耐力良好的女巨人，破坏之神，堪比核弹的超大型巨人，敏捷，体型小，牙口好的鄂之巨人，动物形象的野兽巨人，身手敏捷，可以持久变身的车力巨人，以及浑身铠甲的，岂，不，铠甲巨人。</p><p>尤弥尔死后魂魄被锁定在了“路”里，这个路，是一个什么概念呢，我个人理解为这是一个类似四维空间，相对外面的世界，这里没有时间的概念，或者说这里是外面世界所有时间的交汇处，在这里，时间可以无视，比如尤弥尔就在这里用沙子捏了几十万个超大型巨人。路，连接了所有艾尔迪亚的子民，始祖巨人可以连接路，通过路，来遥控所有的艾尔迪亚子民，甚至改造他们的身体和基因，比如，修改记忆，预防瘟疫（某个传染病席卷大陆，然后艾尔迪亚人却突然免疫了）</p><p>后来的所有的巨人，实际上都是尤弥尔亲手捏出来的，包括城墙里的几十万个超大巨人，历代的智慧巨人等等，甚至艾尔迪亚人来到了路里，都可以修复残破的身躯（吉克）。由此可见，尤弥尔在这里做的事情至少耗费了万年的时间，在这里，尤弥尔仍旧被奴隶的思想束缚着，不知疲倦的劳动着，为弗里茨王族和艾尔迪亚子民辛苦的捏着巨人，非常像一个没有思想的工具，直到后来艾伦到来。</p><blockquote><p>推测：艾伦实际上是她等待了无数年的人，她内心是渴望有人来解放她的。</p></blockquote><h3 id="145王时代"><a href="#145王时代" class="headerlink" title="145王时代"></a>145王时代</h3><p>145王是一个非常关键的人，也是个传奇分子，是一个只存在于传闻中的人，145王在尤弥尔变成巨人的1885年后进行了一个惊人的举动，他带着一部分艾尔迪亚人来到了帕拉迪岛，过上了与世无争的生活，人们活在3道墙中，不再准备和外世联系，然后再过了100年左右，艾伦继承了始祖的巨人和进击的巨人，加上13年的任期，正好距离尤弥尔变成巨人2000年，与动画的第一集“致2000年以后的你”遥相呼应。</p><p>初代弗里茨王已经征服了世界，一直到145王的年代都是如此，8大巨人被八大家族所掌握着，然而因为内乱的原因，纷争不断，这段剧情可能会和100多年后团长的话，以及伊莲娜的话都对的上，这大概是作者自己的想法，这个放在后面说。</p><p>145王出于某种心理，也许是倦了，也许是看大家斗累了，又或者觉得艾尔迪亚人是万恶之源，自己良心发现了，所以，他策划了一场骗局，联合战锤家族和马莱人，制造了一个“英雄”，假装被其打败，带着一大批艾尔迪亚人来到了帕拉迪岛上，用三道墙锁住了自己的人民（三道墙由几十万个超大巨人硬质化组成，这几十万人都是尤弥尔捏的，这几十万个巨人也可能都是挖了眼睛的奴隶变的，详情见135话单眼流泪的小贝，艾伦发动低鸣，使用的也是这几十万的超大型巨人），并给他们洗脑，让他们以为墙外没有人类，只有巨人，并放下狠话“我们将不再出世”，以此求个清净，其中，墙内不能被洗脑的阿克曼家族，以及外岛人都遭到了屠杀，当时在岛上的有三笠的外祖父，东洋国的一个将军。</p><p>说起阿克曼家族，要说明一下概念，阿克曼家族据说是巨人的试验品，简称人型巨人，大概是觉醒之后可以获得阿克曼家族以往的战斗经验，以及拥有强悍的身体素质和反应神经，阿克曼家族的坑其实还没填干净，要等着谏山创去解释，阿克曼家族不可变成巨人，也不能被洗脑，代表人物，三笠·阿克曼，利威尔·阿克曼，肯尼·阿克曼，三笠的父亲是阿克曼血统，母亲是东洋人，三笠于9岁在山间小屋和艾伦与匪徒搏斗的时候觉醒。</p><p>145王与战锤家族貌似有某种协定，这个暂时不得而知，随后，145王给自己设定了一个不战之约，这个约定是与始祖巨人签订的，主要约束他的后代，内容是，拥有弗里茨王血脉的继承者们，都不能使用始祖之人的力量进行战斗，所以，后面的所有王族继承者，都被不战之约狠狠的束缚着。</p><blockquote><p>所以，莱纳来撞门的时候，当任的始祖巨人根本无法抵抗，她谁也救不了。</p></blockquote><p>145王忙活完了这一切，安详的挂了，至此，岛外大一统的艾尔迪亚帝国分裂为无数国家，其中马莱被称为击败了艾尔迪亚恶魔的英雄国家。145王闭岛锁国之后，帕拉迪岛被他称之为乐园，而马莱的八大巨人中，只有战锤家族成为了马莱的高层，其他六大巨人成了马莱军方控制的武器，而进击的巨人不知所踪。145王之后，世界上再无艾尔迪亚帝国，只有马莱帝国，在马莱国的艾尔迪亚人被集中关押在称之为艾尔迪亚收容区的场所，在这里，艾尔迪亚人分为三六九等，这里谏山创应该是参考了二战德国对待犹太人的方式，详情可以看看电影《钢琴师》，艾尔迪亚人必须佩戴袖章，不佩戴袖章的后果是很严重的。</p><p>其中</p><ul><li>红色，代表了荣誉马莱人，是巨人战士，以及战士家属才能佩戴，是艾尔迪亚收容区中最有地位的存在，比如莱纳，和莱纳的家人，</li><li>黄色，代表了战士候补，比如贾碧，法尔科，伍德等，</li><li>银白色，普通的艾尔迪亚士兵</li><li>灰色，普通艾尔迪亚人</li></ul><p>在收容区，艾尔迪亚人是被洗脑的，他们接受的思想是乐园里全部都是恶魔，乐园里的人都是恶魔的后裔，而他们这些人如果不想成为罪恶的艾尔迪亚人，必须忠心的为马莱服务，并且不能反抗，反抗了，会遭到连坐，和家人一起，被注射巨人脊柱液，送往乐园，变成无垢巨人。</p><blockquote><p>（艾尔迪亚人，人人都可以通过注射巨人脊柱液的方式变成无垢巨人，污垢巨人就是最普通的无脑巨人，巨人脊柱液来自于智慧巨人，变成巨人的方式还有其他的方法，后面说）</p></blockquote><p>接下来讲讲艾伦的父亲，格力沙的故事。</p><h3 id="格力沙"><a href="#格力沙" class="headerlink" title="格力沙"></a>格力沙</h3><p>格力沙的故事，发生在不战之约建立后，超大巨人和莱宝来踢门之间的100年中，有up主说是107年，但是我还没有找到具体的资料，就暂且称之为100年。期间，有一个马莱的小乞丐，被马莱的地下教派带走，当作“尤弥尔”来祭拜，后被马莱人发现，将她带到了乐园，变成了污垢巨人，在后面的剧情中，这个女孩吞食了莱纳的同伴，意外的变成了人类，她是希斯特里亚一生的朋友，尤弥尔，简称104尤弥尔，和始祖尤弥尔区分开。</p><p>格力沙是一个马莱艾尔迪亚收容区出生的孩子，他有一个妹妹，他的父亲和母亲深受马莱人的洗脑，从小就灌输他岛内恶魔论，并强迫格力沙继承自己的职位，医生，然而格力沙却是一个很叛逆的人，他不明白艾尔迪亚人为什么要遭受这些，某天，他带着妹妹在街上散步，发现了一个飞行器，他很想知道飞行器会在哪里降落，就带着妹妹跑出了收容区，正好撞见了在收容区外的河边偷懒的马莱警察，警察暴打了格力沙一顿，又放出了鬣狗，残忍的咬死了格力沙的妹妹，不仅如此，马莱警察还堂而皇之的来到格力沙的家里，指责格力沙的父亲教育不好孩子，格力沙，格力沙的父亲，都陷入了深深的自责之中，格力沙后悔自己害死了妹妹，父亲后悔平时太逼迫格力沙了，让他感觉到了压抑才会造成惨剧，都是自己的责任（第四季第四集中与艾伦对话中透露）。</p><p>在格力沙18岁的时候，他都准备接手父亲的诊所度过自己平凡的一生了，这个时候，命运发生了转变，在黄毛（法尔科和柯特的亲戚）的引领下，格力沙加入了艾尔迪亚复权派，这是一个地下组织，组织者都是艾尔迪亚人，目的是为了振兴艾尔迪亚，复权派的首领是一个神秘的人，叫做枭，然而从来都没有人见过枭的真面目，在这里，他结识了自己的第一任妻子，黛娜，值得一提的是，这个黛娜，是弗里茨王族的后裔，拥有王血，这个时候，马莱的明面上是不存在拥有王血的艾尔迪亚人的，一旦发现，这个人可能会被马莱控制，沦为生育机器，黛娜拥有王血，这个是复权派最大的秘密。</p><p>黛娜对复权派的积极分子格力沙一见钟情，两人迅速结婚，格力沙不久和黛娜拥有了一个孩子，叫做吉克，就是艾伦的哥哥，后来的猴子巨人，在吉克7岁的那年，吉克举报了自己的父母是艾尔迪亚复权派，格力沙和黛娜因此被捕，这次事件中，吉克并不是故意要举报自己的父母，是因为当时他无意的听见了军人们的谈话，复权派已经暴露了，父母已经被锁定了，在咨询了当时的野兽巨人的拥有者汤姆·库沙瓦之后，小吉克才这么做的。</p><p>吉克的童年是很悲催的，父母天天给他灌输复权派的思想，他感受不到丝毫家的温暖，陪伴他的只有那些玩具，其中他最喜欢的是猴子玩具。</p><p>吉克在家里没有情感寄托，但是他在外面认识了一个朋友，是当时的野兽巨人持有者，库沙瓦先生，库沙瓦先生是个巨人科研人员，属于巨人学的大拿，如果韩吉生在马莱，这两个人也许会是师生吧，野兽巨人从古至今都是最弱的巨人，不是变成鸟啊，就是乌龟大象什么的，并不能算作是战斗力，然而库沙瓦肯定想不到，以后吉克操纵的猴子巨人，会是无数人的噩梦。</p><p>库沙瓦和小吉克亦师亦友，两个人一起讨论巨人，一起打棒球，吉克的投掷技巧就是这个时候练成的，库沙瓦也讲了很多关键的巨人信息，比如，始祖尤弥尔可以随意改造艾尔迪亚人，不仅仅改造身体，还包括基因，证据就是艾尔迪亚人一夜之间对瘟疫免疫这件事，简单来说，拥有始祖巨人，艾尔迪亚人将被改变，万事皆有可能，这段信息，可能成了吉克以后的计划的基石。</p><p>在吉克7岁的那年，他无意听到士兵在讨论要收网抓捕父母的话，他惊慌的回到家，问父亲如果他们暴露了怎么办，结果格力沙依然是在无能狂怒，用那套复权理论洗脑吉克，吉克很失望，来到了库里沙面前，库里沙冷静的给他指了一条路。</p><p>举报父母，这样他还有未来，爷爷奶奶也不会被连坐，这是最好的解决方式了。</p><p>吉克痛苦的作出了这个决定，当天，格力沙和黛娜被捉捕，吉克成了大义灭亲的英雄小孩，还称为了战士候补，而格力沙，马上就要去往乐园了。</p><p>被捕期间，吉克为了保住黛娜的性命，告诉了审判者黛娜是王血这一情报，但是黛娜依旧被带往乐园，大家的推断是，在审判环节，枭扣押了黛娜是王血的这一供词，或者说，有可能不只一个人提供了黛娜是王血的这个供词，但是被枭扣押了，是的，枭就是这次审判的相关负责人，没想到吧。</p><p>开往到帕拉迪岛后，人们被挨个的注射了巨人的脊柱液，变成了无垢巨人，黛娜在变身前，留着眼泪说，格力沙，无论你在哪里，我都能找到你，这句话被视为执念的代表，是黛娜变成奇行种的关键。</p><p>在只剩下格力沙一个人还没有被注射的时候，伪装成警察的枭动手了，他干掉了所有的人，并变身为了进击的巨人，击毁了马莱的战舰，然后，枭和格力沙讲述了巨人的历史…</p><p>枭本名叫做艾伦，他要求格力沙继承进击的巨人，并且前往墙内，抢夺始祖巨人，复兴艾尔迪亚。继承巨人的方式，目前只知道一种，就是让继承者变声成无垢巨人，啃食前任巨人拥有者，吸食他的脊髓液后，就可继承他的巨人之力。于是，格力沙按照枭的吩咐，继承了进击的巨人。期间，枭曾经和格力沙说过这样的一段话</p><blockquote><p>“进入墙内以后组建一个家庭，这样，你才能够保护三笠，阿尔敏。”<br>“你在说什么阿，我已经有黛娜了，而且你说这些也没用阿，变成巨人之前的一小段记忆不是会丢失吗？”<br>“不一定的，说不定后面会有人会看到。”<br>“妻子也好，孩子也好，其他的人也好，要在墙内爱别人，如果做不到的话，就会和过去一样，无数次重演历史，重蹈覆辙，如果想拯救三笠，阿尔敏，还有大家的话，就去完成使命吧。”<br>“..哎？三笠和阿尔敏是谁呢？”</p></blockquote><p>这里说一下进击的巨人，进击的巨人，没有铠甲，没有锋利的牙齿，有的只有不被控制的能力，他是自由的，进击的巨人可以无视始祖巨人的控制，这也是为什么后来艾伦不受不战之约的影响，巨人的继承者可以看到前任的所有巨人持有者的记忆碎片，而进击的巨人不仅可以看到前任的巨人持有者的记忆，甚至可以看到未来，还有未来的进击的巨人持有者的记忆，在后面，可以出现艾伦通过进击的巨人的能力，影响格力沙的片段，而枭口中的三笠，阿尔敏两个人的名字，恐怕也来自于枭对艾伦记忆的窥探，或者是受到了艾伦的影响。</p><blockquote><p>说一个贴吧的推论：艾伦，没有看过未来的进击的巨人继承者的记忆，所以，艾伦应该是最后一任进击的巨人，至于法尔科看到自己在天上飞，这不是进击的巨人的能力，他看到的应该是前面的某个野兽巨人变成的鸟型巨人。</p></blockquote><p>格力沙来到玛丽亚墙外的时候，已经变成了人的形态，碰巧遇见了12任调查兵团的团长，艾伦的教官，格力沙的挚友，基斯·夏迪斯，格力沙跟随着他，来到了墙内。在墙内，他凭借着马莱的医术，称为了一名医生，并且在一场瘟疫中，救了很多人，包括汉尼斯大叔，卡露拉的亲人，等等，后来，基斯的梦中情人，卡露拉，嫁给了格力沙·耶格尔，生下了一个小男孩，叫做艾伦。</p><h2 id="破墙前夕"><a href="#破墙前夕" class="headerlink" title="破墙前夕"></a>破墙前夕</h2><h3 id="兵长利威尔"><a href="#兵长利威尔" class="headerlink" title="兵长利威尔"></a>兵长利威尔</h3><p>兵长出生在希纳之墙中的地下街里，隶属于希纳之墙的范围内。</p><p>三道墙中，玛丽亚之墙是最外面的墙，地盘也是最大的，玛丽亚之墙的四个方向有四个类似于瓮城的城镇，据说是吸引巨人用的，在这里生活的平民会有补贴，最南方的瓮城就是艾伦的故乡，希甘希纳区，其次是罗塞之墙，最后是希纳之墙，墙内的制度和社会模式也是一个非常值得研究的话题，这里我就长话短说，希纳之墙之中住的都是王公贵族，简称皇亲国戚，管理的非常严格，并且这里的居住权是非常难以获得的，宪兵团团长奈尔，可以说是在墙内的军方属于第一阵列的高官，但是即使是他，都没有资格获得在希纳之墙的居住权，更不要说居住在地下街的兵长等人了，三道墙管理森严，出入不同的地区需要通行证，这个在阿妮的外传中有所体现，地下街可以理解为贫民窟，类似于巴西贫民窟的模式，充满了孤儿，穷人，病人，毒品，还有黑帮，在地下街，人们可以买到任何想要得到的东西，甚至是军方的立体机动装置，同一片天空下，地面上是金碧辉煌的贵族天堂，地下是命如草芥的穷人地狱，真的是相当讽刺，壁内的社会有报社，有商会，大概是欧洲中世纪的模样，军队独立，却并不属于贵族，这点和我们的世界完全相反，可能因为墙内有始祖巨人，所以贵族不需要军队的控制权，也因此，在王政篇团长等人可以成功的进行没有硝烟的政变。</p><p>墙壁内的王是个傀儡，真正的统治者是雷斯家族，就是弗里茨王，145的后代，目前是罗德·雷斯，他的女儿掌握着始祖巨人。</p><blockquote><p>兵长外传《无悔的选择》里记载<br>『根据史料记载 人类有段时间曾考量过移居地下 以躲避巨人的袭击 』<br>『但结果 迁徙终止 残留的建筑物废墟成了贫民与犯罪者的栖息地』</p></blockquote><p>利威尔的母亲是阿克曼血统，是地下街的一名妓女，在利威尔出生后就因病去世了，在利威尔将要饿死的时候，利威尔的舅舅出现了，就是肯尼·阿克曼，肯尼给了利威尔食物，教会了利威尔使用刀具，合理认为在此期间利威尔的力量觉醒，在肯尼看到利威尔在闹市狠狠的教训了一个胖子的时候，肯尼离开了利威尔，也许是他觉得他可以教给利威尔的都已经教给他了，多年以后利威尔询问肯尼当年为什么离开他，肯尼说，“我不觉得我自己可以成为一个父亲的角色。”</p><p>在地下街，兵长的战斗力是显而易见的，很快的就混的如鱼得水，也许是兵长对于回到地面上生活有所向往，又讨厌这肮脏的地下街，所以他有着很严重的洁癖，兵长的性格也十分古怪，一方面他经常面无表情，遇到事情秉承着能动手不嘚嘚的原则，对待敌人非常暴力，一方面他又面冷心善，在地下街，他认识了一个好朋友，叫做法兰，后来又在黑帮手里救下了一个叫伊莎贝尔的妹子，从此地下街三人组成立（谏山创不仅是对称狂魔，还非常喜欢塑造三人组，幼驯染，兄与弟的关系），他们熟练的掌握了立体机动装置，在地下街里没人能得罪他们。</p><p>某天，一个大人物找到了利威尔，以回到地面，并且治疗利威尔的一个软骨病朋友为筹码，去忽悠利威尔刺杀埃尔文·史密斯，兵长答应了，大人物告诉利威尔，调查兵团可能会最近来找他，要他找机会动手。</p><p>调查兵团果然来到了地下街，并且迅速的制服了三人组，兵长三人组加入调查兵团，但是很遗憾，在第一次出任务的时候，兵长的两个伙伴，第一届的利威尔班，就以阵亡这个结局草草收场，在任务的过程中，利威尔其实十分担心同伴的安危，但是同伴却让兵长放心自己，让他大胆去做自己该做的事情，结果两个好友命丧巨人之口，这也是后来兵长在巨木森林中和艾伦对话，说自己也不知道到底应不应该做的来由。</p><p>在这次任务结束后，团长告诉利威尔，那个要谋害他的大人物已经完蛋了（这里算是团长第一次表现出自己超高的政治天赋），利威尔问团长，为什么你一开始就知道我要来杀你，你却还要这么做，团长又开始他的演讲天赋，一通大义言论下来，利威尔选择和团长冰释前嫌，并肩作战，有人问谏山创，利威尔为什么要加入调查兵团，作者是这么说的：“利威尔之所以迄今为止都与其并肩作战，正是因为他把埃尔文所鼓吹的“为了人类的未来”这一目的当成了自己从来都没有想过的利他行为，并将此作为了自己的人生使命。因此，利威尔也要求埃尔文也“忠于自己的使命”“作出冷静的判断”，结果知道了埃尔文的“梦想”实际上是一个利己主义目的的时候，利威尔又有了一种被背叛的感觉，不过觉得“没想到这个对自己绝对无法战胜过的这个男人居然也有追逐梦想的孩子的一面阿。”。”</p><p>从此，地下街的混混利威尔不见了，只有调查兵团那个被称之为传奇的利威尔兵长。</p><blockquote><p>兵长，意思是兵士长，是一个职位很高的军衔，某些翻译为士兵长，会被误认为是低阶官衔。</p></blockquote><h3 id="埃尔文·史密斯"><a href="#埃尔文·史密斯" class="headerlink" title="埃尔文·史密斯"></a>埃尔文·史密斯</h3><p>埃尔文·史密斯，调查兵团第十三任团长，看到他的时候大家往往联想到三体的托马斯·维徳以及章北海，看来成功的角色都有其共同的魅力，如果说兵长是一个战场上的终究兵器，团长就是一个伟大的军事家，政治家，他的两大天赋就是演讲和布局，和前任团长基斯的无能，下任团长韩吉的学院派风格不同，团长就是一个彻彻底底的马基雅维利主义者，就是那种为了达到目的不择手段的人，然而生命的最后时光他放弃了理想选择大义，让人唏嘘不已。</p><p>说起团长的经历，得先说一个人，就是利威尔的舅舅，肯尼·阿克曼，肯尼在离开了利威尔后，想要为被屠杀的利威尔家族报仇，找到了当时的雷斯家族的巨人继承者，乌利，在始祖巨人的力量下，肯尼第一次感觉到了恐惧，然而乌利却毕恭毕敬的和他道歉，从此，他成了乌利的好友，也称为了王族的鹰犬头子，他自己成立了一个私人武装，名字叫做中央宪兵团，这个组织是在水面之下的，专门替王族去除一些“多余”的人，其中就包括阿尔敏的父母，希斯特里亚的母亲，还有埃尔文的父亲等等。</p><p>埃尔文的父亲是一名教师，在一次讲历史的课上，埃尔文向父亲提问，为什么书上写的话不严谨，为什么是“100年前，出现了巨人，墙外的人类都灭绝了。”而不是“墙外的人类可能已经灭绝了。”埃尔文的父亲制止了他的提问，晚上回到家里，和埃尔文说了一些对巨人的秘密的假设，在第二天，埃尔文和同学在谈论父亲给他讲述这些假设，被中央先兵团的人偷听到了，然后当天晚上，父亲就没有再回家，后来得知父亲因为“意外”死于非命了。</p><p>自此，团长的心目中有了一个超越一切的梦想，想要知道这个世界的真相，带着对父亲的愧疚，他加入了调查兵团，接替了基斯的团长之位，挖掘了利威尔，发明了探索阵型，大大的减少了调查兵团的伤亡，一代枭雄出现。</p><blockquote><p>以上内容，部分灵感来自于b站的一个用户，需要笑，他的视频不错，文案很有水平，感兴趣的可以去看看</p></blockquote><h3 id="马莱"><a href="#马莱" class="headerlink" title="马莱"></a>马莱</h3><p>破墙前夕的马莱仍旧出于世界的霸主地位，在这一届的战士候补中，有七位优秀的孩子，分别是吉克，皮克，马赛和波波（波尔克）兄弟，莱纳，阿妮，其中莱纳选手是七个人中的吊车尾，莱纳这个人阿，作为进击的巨人中第二个塑造的非常的成功的角色（第一个是团长），在马莱时期是非常激进的，他也有一个非常悲催的童年，他的父亲是一个马莱人，母亲是艾尔迪亚人，他的出生纯属是个意外，他的父亲根本就不认他，他的母亲只想成为荣誉马莱人过上好日子，疯狂的给莱纳洗脑，后来是给贾碧洗脑，莱纳天真的以为成为了战士，成为了荣誉马莱人，就能和爸爸妈妈三人一起生活，为此他玩命的讨好马莱，甚至在和波波的争吵中还要给波波扣艾尔迪亚复权派的帽子，莱纳和波波的关系就很像艾伦和让，谁也不服谁。</p><p>战士候补中，吉克是为了心目中的计划，和受到了库沙瓦的影响而去继承野兽巨人的，皮克是为了给父亲治病才来继承车力巨人的，阿妮是被想要成为荣誉马莱人，过上好日子的养父要求来继承女巨人的，贝尔托特是继承超大型巨人的，并且，他是个人才，正常人第一次变身为巨人的时候都会暴走，但是他没有，第一次就熟练的掌握了超大型巨人，马赛继承了颚之巨人，但是他不想弟弟早死，所以他和马莱方经常夸莱纳，贬低波波，最后莱纳如愿以偿的继承了铠之巨人。</p><blockquote><p>马赛是否是直接导致莱纳继承铠之巨人的原因是未知的，也可能是马莱看重莱纳的忠诚。</p></blockquote><p>阿妮的父亲是一个格斗术很厉害的人，漫画里讲他是从其他地方来到马莱的，从小就用近乎暴力的方式教阿妮格斗术，个人感觉阿妮都有点斯德哥尔摩了，她在养父近乎摧残的训练下，竟然把养父当作了自己的精神支柱，也因此成了一个冰山美人，阿妮从来都不在乎什么荣誉马莱人，什么任务，什么未来，她只想和养父好好的过日子，在后来阿妮去帕拉迪岛的时候，养父似乎也后悔了，哭着求阿妮活着回来。</p><p>在几人继承了巨人之后，又参加了几次战斗，灭了几个国家，甚至超大巨人直接用爆炸能力摧毁了某国的首都，在这之后，莱纳，阿妮，贝尔托特，马赛，被马莱方指派前往帕拉迪岛，夺回始祖巨人。</p><p>当时的马莱，依旧是世界霸主，但是其他国家的发展也是飞快的，为了未来考虑，始祖巨人是要夺回的，这算是大方向上的战略。在行动之前，莱纳去找到了他的父亲，却被他父亲一顿臭骂赶了出来，这是他第一次，对于母亲给他灌输的艾尔迪亚恶魔论产生了动摇。</p><blockquote><p>荣誉马莱人？简直是个笑话罢了。</p></blockquote><p>四个人风风光光的坐着大船开往了帕拉迪岛，马莱方还给了他们行动的时间和来接应的时间范围。然后一上岛，他们就遇见了大麻烦，在原本的计划中，在海岸到墙壁这段路中，将由阿妮和马赛轮流变身成为巨人带着其他三个人赶路，然而在他们烤着篝火的时候，沉睡在地下的一个无垢巨人苏醒了，这个无垢巨人就是后面的104尤弥尔。当时马赛正在和莱纳道歉，为了自己当初为了保护弟弟而暗箱操作的行为道歉，104尤弥尔的突然袭击让一群人慌了阵脚，马赛推开了莱纳，被104尤弥尔啃食了，而这个时候的莱纳却扭头逃跑了。</p><p>莱纳逃跑了很久，停了下来，他开始恐慌，因为计划还没实行，就因为自己导致马莱失去了一个巨人，更何况马赛还是这次行动的指挥，自己这责任可太大了，这个时候阿妮和贝尔托特也赶来，阿妮愤怒的指责莱纳，并说莱纳竟然第一次比她跑的还快，阿妮表示要回到马莱，莱纳不同意，贝尔托特提议回去回收颚之巨人，也被莱纳否定了，阿妮气的对着莱纳的脑袋一顿猛踢，莱纳倒在地上，满头都是血，在阿妮准备回到岸边的时候，莱纳悄无声息的站起来了，他勒住阿妮的脖子，让她都喘不上气来，他低声说，“如果你们需要马赛，那就让我成为马赛吧。”</p><blockquote><p>这大概是莱纳精分之路的起点吧。</p></blockquote><p>阿妮妥协了。</p><p>之后，阿妮变成为女巨人，带着莱纳和贝尔托一路狂奔到玛丽亚城墙，到达的时候阿妮的体力已经透支了，结束了变身就昏了过去，在靠近城墙之前，她通过吼叫吸引了无数的无垢巨人，贝尔托特变身为超大巨人踢破希甘希纳区的城门，莱纳变身铠之巨人撞开了玛丽亚之墙的城门。</p><p>在贝尔托特变为人型的时候，他看到奇行种黛娜和他擦肩而过，无视了他（奇行种，没有规律，行动古怪的无垢巨人）。</p><p>在结束撞墙之后，三个人在难民区盘腿而坐，莱纳搂住贝尔托特和阿妮的肩膀，给他们打气，不远处，刚刚失去故乡的艾伦，三笠，阿尔敏在交谈着。</p><p>巨人年845年，玛利亚城墙失守。</p><h3 id="墙内"><a href="#墙内" class="headerlink" title="墙内"></a>墙内</h3><p>在兵长在地下街混日子的时候，希斯塔利亚还在农场里干活儿，每天面对的就是牲畜，庄稼，冲她扔石头的小男孩，还有不和她说一句话的母亲，阿尔玛。</p><p>希斯特里亚的母亲很喜欢看书，于是希斯特里亚也看书，她看到很多书上记录了母亲是很温柔的，但是她的妈妈是冷漠的，于是有一次，她想要和妈妈亲近，她扑过去和妈妈撒娇，却被妈妈一把推开了，妈妈忌讳的冲她吼叫，“离我远点，要是我有勇气，有勇气…”，对于妈妈的惊恐，希斯特里亚却很高兴，因为妈妈终于理她了，在农场的时候，有一个大姐姐经常来看她，大姐姐的眼睛非常的漂亮，大姐姐教她读书写字，两个人聊的很开心，可是希斯特里亚每次见面后都会把大姐姐忘记掉。</p><p>希斯特里亚的妈妈经常大半夜打扮的花枝招展的，然后乘坐一辆漂亮的马车离开，黎明时分再回来，直到某一天，一个胖子来到了她家，说自己是希斯特里亚的父亲，要接她们母女走，却被一个带着礼帽的家伙拦住了，这个人杀了她的母亲，还要杀了希斯特里亚，希斯特里亚的母亲临死之前疯狂的喊着不认识希斯特里亚，然而没有任何用，在这个戴着礼帽的混球拎着刀不怀好意的走向希斯特里亚时，被这个自称是她父亲，叫雷斯的家伙拦住了，他提了一个建议，让希斯特里亚改名，离开这里远走他乡，以求饶她一命，戴礼帽的家伙同意了。</p><p>于是，希斯特里亚改名为赫里斯塔，加入104期新兵。</p><p>她不知道的是，因为她的原因，另外一个女孩也选择了加入104期新兵，这个女孩叫做尤弥尔，104尤弥尔。</p><blockquote><p>此处分析：据雷斯的回忆，阿尔玛是唯一能理解他的女人，如果罗德·雷斯没有说谎，阿尔玛可能是个聪明人，为了希斯特里亚的安全才故意疏远她。</p></blockquote><p>而墙内的格力沙一家，在墙内平静的生活了十年，期间，艾伦在9岁的时候，救了三笠。</p><p>三笠父母本来是格力沙的好友，格力沙也会定期来三笠家为三笠的家人看病，有的时候就会带着艾伦，小时候的三笠是个软妹子，某次艾伦带着三笠去森林里玩，遇到了几只狼在啃食落难者，三笠非常的害怕，狼冲着他们就来了，这个时候三笠的心跳加速了，狼却莫名其妙的扭头走了，两个人因此非常费解。</p><blockquote><p>有朋友 私信提醒我，这一段出自三笠的oad，是幻想的内容，并不在巨人的主线之中，在此作者做一个声明。</p></blockquote><p>某天，三个强盗来到了三笠家，杀害了三笠的父母，碰巧当天艾伦也来了三笠家，艾伦为了救三笠，来到了三笠被强盗关押的小屋子，用智谋杀了一个强盗，又突袭了另外一个强盗，结果被第三个强盗扭住了脖子（不得不说09伦真的有勇有谋，且第一次杀人就无所畏惧，莱纳这时候还在马莱给波波扣艾尔迪亚复权派的帽子呢），在艾伦的嘶吼中，三笠觉醒了自己的血统，救下了艾伦，就在那天，格力沙收养了三笠，艾伦亲手为三笠带上了对她最最重要的红围巾。</p><p>在希甘希纳区，艾伦经常打架，理由千奇百怪，有时候是因为和别人吵起来了，有时候是因为自己的朋友阿尔敏，阿尔敏是一个孤儿，和爷爷一起生活，父母因为研制热气球想要飞向天空看看外面的世界被中央宪兵团给处理了，阿尔敏有一本书，里面记录了很多神奇的东西，比如无边无尽的盐水，燃烧的水，冰封的大地等等，本来就渴望自由的艾伦和阿尔敏一拍即合，立下了要去墙外看一看的愿望。</p><blockquote><p>艾伦这个人呢，是本书的男主角，他的性格其实变化的很跳跃，也非常的离谱，在9岁就能平静的杀死强盗，并且还会用计谋杀人，在希甘希纳区又非常的无脑，十分的冲动，在后来的15伦时代，更是冲动和无脑的典型，团长的反义词，到了19伦，又是布局恢弘的智者和影帝。</p></blockquote><p>三笠就不用说了，嘴上不承认，其实最喜欢艾伦，阿尔敏也是两个人最好的朋友，我看巨人的最大原因就是被幼驯染三人组的感情所打动。</p><p>艾伦的梦想是加入调查兵团，因为调查兵团是和巨人作战的，在艾伦自己的认知里，活在墙里的人们和牲畜是没有区别的，这一观点三笠是不赞同的，还和艾伦的母亲说了艾伦的想法，艾伦被母亲好一顿训斥，但是，父亲却没有表态，只是说自己要办事，回来之后，会给艾伦看他一直想要知道的关于巨人的秘密。</p><p>在破墙前夕，艾伦砍柴时摸鱼，睡着了，醒来后问三笠为什么头发长了，这一段剧情可能是进击的巨人的能力，他看到了未来的记忆碎片。</p><p>艾伦和三笠回去的途中遇到了驻扎兵团的汉尼斯大叔，汉尼斯大叔被格力沙救过一命，对艾伦也很宠爱，就开艾伦的玩笑，艾伦却指责他只会喝酒，根本不做事。</p><blockquote><p>这里可以看出，15伦的情商低是从小自带的，估计09伦的围围巾和淡定的杀强盗都是意外。（开个玩笑，皮一下）</p></blockquote><p>醒来之后他看到了铩羽而归的调查兵团，当时还是基斯当团长，埃尔文看到了艾伦，别扭的扭过了头，调查兵团的氛围很悲伤，一位老妪寻找自己的儿子，基斯却只递过来一条胳膊，老妪失声问道，自己的儿子为了人类做贡献了吗？基斯痛苦的说，没有！这次调查，依旧是一无所获阿！</p><p>众人的嘘声和愤怒的喊叫声里，调查兵团死寂的气息和下跪的基斯团长非常的刺眼，艾伦冲着一个唱衰调查兵团的大叔扔东西，在被揍之前被三笠拽走了，三笠再次要求他不要加入调查兵团，艾伦坚决不同意，然后回到家，就发生了三笠揭发他的一幕。</p><p>在父亲走后，艾伦出门帮阿尔敏打架，本来那群小混混还想连他一起揍，但是看到了三笠也在，吓的直接跑了，接下来，城中的人们的目光都被夕阳下的城墙吸引了。</p><blockquote><p>城墙上出现了一个红彤彤的大脑袋。<br>那天，艾伦上校面对行刑队……不<br>那天，人们终于回忆起了被巨人支配的恐惧……</p></blockquote><h2 id="破墙之后到新兵结束"><a href="#破墙之后到新兵结束" class="headerlink" title="破墙之后到新兵结束"></a>破墙之后到新兵结束</h2><p>大家都被这个巨人给震惊了，这里贡献了动画里的第一个名场面，阿尔敏的声优说道，“那天，人们终于回想起了被巨人支配的恐惧。”随着超大型巨人的一脚下去，城门被踢的粉碎，无数巨人从城门涌入，城门损坏时飞出的巨石飞向了艾伦的家，压坏了艾伦家的房屋，把艾伦的母亲，卡露拉压在了底下。惊慌的人们很多都是第一次看到巨人，吓的瘫软在了地上，壁教的传道士高声的朗诵着诗经，与逃窜的人群背道而驰，然后被巨人吞进了肚子。艾伦和三笠疯狂的跑向自己的家，却发现无论如何也不能把自己的母亲从废墟里拉出来，这个时候，奇行种黛娜正一步步的朝着他们走来。</p><p>汉尼斯大叔来到了艾伦家的废墟前，他看了一眼正走过来的奇行种黛娜，又尝试着拉出卡露拉，但是他失败了，在卡露拉的请求下，大叔叹了口气，背起了艾伦和三笠就玩命的逃跑，卡露拉不停的大喊着，“跑！快跑阿！”，在卡露拉看着他们越来越远之后，她用手捂住自己的嘴，默默的流泪，小声的说，“别，别丢下我一个人阿…”</p><p>艾伦疯狂的喊叫着，在夕阳的余晖里，他看到了奇行种黛娜拨开废墟，咬碎了卡露拉的身体…艾伦在此处，立下了“要将巨人一匹不剩的全部驱逐出去！”（这里注意一点，艾伦用的是匹，不是只，日语里只形容大型生物，匹形容小型生物，这里有蔑视巨人的意思，不愧是进击的巨人之子）在来到了安全的地带，艾伦来到地面就想殴打汉尼斯大叔，但是大叔痛苦的道歉，对不起阿艾伦，是我没有能力阿，艾伦怔住了…</p><p>与此同时，莱纳变成了铠之巨人，做出了他一生中最罪恶的一件事情，他以冲锋的方式，撞开了玛丽亚之墙尚未完全关闭的城墙，士兵的炮击，对他完全无效，他以一个无敌的姿态击碎了城墙，从此，玛丽亚区失守。</p><p>六神无主的艾伦被阿尔敏和三笠带上了满载的难民船，通过河道去往了罗塞之墙，在那里，他吞食了自己的父亲…</p><p>画面给到格力沙，格力沙在十年的行医生涯中，也渐渐的摸清了墙内的形势，这次离开，他是要去和始祖巨人谈判的，雷斯家族的大本营在一个大教堂的地下，当天，雷斯家族的族长罗德·雷斯和他的五个孩子都在地下室，包括掌握始祖巨人的芙莉坦·雷斯。格力沙要求芙莉坦使用始祖巨人进行战斗，却被芙莉坦无情的拒绝，实际上芙莉坦自己也没有办法，因为她被不战之约束缚着。  格力沙绝望的喊到：“我的妻子，女儿，儿子都在那里啊！”然而芙莉坦不为所动。</p><p>芙莉妲·雷斯是罗德·雷斯的长女，是希斯特莉亚同父异母的姐姐，继承叔父乌利的巨人之力成为墙内实际的女王，她经常陪伴小时候的希斯特莉亚，并且教导她读书认字，不过为了希斯特莉亚的生命安全，每次离开她之前，会先用自身的巨人之力把希斯特莉亚的记忆消除，芙莉妲拥有的巨人之力（即始祖巨人）是立于所有巨人之上，说白了就是无敌的巨人之力，座标还有窜改记忆的能力就是其一部分力量，不过此巨人之力不在雷斯家的人体内，会无法发挥全部的力量。</p><p>在听到弗莉坦的拒绝之后，绝望的格力沙变身为进击的巨人和弗莉坦进行决斗，这个时候，罗德·雷斯选择了抛弃家人，独自跑路，事后证明他是明智的，因为进击的巨人吞食了芙莉坦，为了斩草除根，还杀害了其余四个孩子。</p><blockquote><p>这次的行动中，格力沙其实是受了某个人的影响才去杀了这四个小孩子的，究竟是谁影响了他，大家不妨猜一猜。<br>还有，动漫里芙莉坦貌似是直接被杀，动画里好像是自愿赴死，或者说已经知道了结局，所以并不想逃跑，她安排了四个弟弟妹妹逃跑，却没能成功。</p></blockquote><p>得手了之后的格力沙通过基斯·夏迪斯找到了艾伦，这时候他的进击的巨人的任期也差不多到时间了，吞食智慧巨人也不能叠加他的寿命，他拿来了巨人脊髓液，在艾伦的挣扎下，告诉了艾伦，一定要回到玛丽亚的那个家，那个家里有着巨人所有的真相，在把钥匙交给艾伦后，使用针剂把艾伦变成了无垢巨人，被其吞食。</p><p>醒来后的艾伦因为巨人继承会失去继承前的小部分记忆的原因，并不知道发生了什么，但却发现钥匙出现在了自己的脖子上，因为一直想要参加调查兵团，现在正好也是个机会，难民太多，当兵至少可以有饭吃，于是三人组去参军了，这个时候，阿尔敏的爷爷就没有那么幸运了，王政府以“讨伐巨人，夺回玛丽亚之壁”为名，安排几十万难民出城，其实就是送死，阿尔敏的爷爷，就在这群人之中。</p><p>这段时间里，有艾伦和吐槽难民的士兵长官争吵，并且拒绝吃他发放的面包的情节，在三笠的“安抚”下，艾伦还是流泪吃了，“吃吧，吃下去才有力气报仇”，因为这个情节，我觉得三笠的形象立起来了，像个有血有肉的人，而不仅仅是主角的附庸。</p><p>于此同时，马莱三人组也在潜伏着，本来他们在种地</p><p>某天，阿妮去调查始祖巨人，这次的目标锁定在了肯尼·阿克曼的身上，肯尼的身手自不必说，神不知鬼不觉的就给阿妮来了个反跟踪，肯尼问阿妮是谁，阿妮淡定的说，“爸爸，你真狠心阿，一声不吭的就抛弃了我们母女。”肯尼笑了，说道，“有意思，我已经答应了我那个妹妹，不会寻花问柳，你这个理由，也找的太无耻了。”阿妮猛的一个劈腿踢向肯尼，肯尼为了躲闪，一个趔趄，阿妮趁机跳进了大人进不去的下水道逃跑了（这里的阿妮留的是104期的米娜的发型，也有说法是跟踪肯尼是在104期时期发生的故事）。</p><p>回来以后，莱纳觉得种地也不是回事，决定要参军，这样更能获得情报，三人组一致同意，他们回想起了之前遇到过的一个老人，这个老人住在一个山里，某一天起床，打开窗户，突然发现了一只巨人在看着他，他吓的抛弃了自己的三个孩子，三个和莱纳他们差不多的孩子，自己逃跑了，老人看到了他们三个，就想到了自己的罪恶，第二天，老人上吊死了，这个老人对三人组的影响是很大的，因为老人的悲剧，完全是他们三个造成的阿！</p><p>在参军后，贝尔托特交代自己的出身时，原封不动的转述了老人的话，但是第一人称却换成了他自己，抛弃的三个孩子也去掉了，马莱三人组，取代了那三个死去的孩子的身份。</p><p>自此，104期这一批群雄汇聚，卧虎藏龙，八仙过海，各显神通的新兵在训练营里相遇了。（104期不仅仅只有艾伦这一批，在不同的区也有同期生，比如后面的希琪和马尔洛）</p><p>按照后来的前十排名，大家可以看看，这队新兵绝对是史上战斗力最强的新兵。</p><blockquote><p>第一名：三笠·阿克曼，阿克曼血统，人类最强利威尔的同胞<br>第二名：莱纳·布朗，铠之巨人<br>第三名，贝尔托特·胡弗，超大型巨人<br>第四名：阿妮，女巨人<br>第五名：艾伦·耶格尔，进击的巨人，始祖巨人<br>前五名就没有一个普通的人类<br>第六名：让<br>第七名：马尔科<br>第八名：萨沙·布劳斯<br>第九名：康尼<br>第十名：赫里斯塔（尤弥尔让她的）<br>这十个人与阿尔敏和尤弥尔称为十二小强</p></blockquote><p>在作品中，新兵时期主要是描写各个角色的性格的，就说主角团，三笠，阿妮都是冰山美人。阿妮经常教艾伦格斗术，名为格斗术，其实就是暴揍艾伦，有一次三笠还吃醋了，要和阿妮单挑，但是那次单挑的结果艾伦却记不得了，这段经历教会了艾伦许多，他也确实学会一些格斗技巧，在后来和铠之巨人打架的时候发挥了巨大的作用。三笠只和艾伦，阿尔敏亲近，后来和萨沙也算说的上话，阿妮则和米娜成为了闺蜜。在阿妮教艾伦格斗的那集，有一个小细节，艾伦和莱纳在练习，莱纳表演持刀歹徒，艾伦为正义者，两人对抗过后，莱纳把刀递给了艾伦，“现在，轮到你来当坏人了。”这是一个非常隐晦的暗示，代表了两人以后的立场转变。</p><blockquote><p>有趣的是，教官问他们为什么来到这里的时候，莱纳说的是拯救人类，某种意义上他没说谎，马莱人眼中艾尔迪亚确实是恶魔呀。</p></blockquote><p>基斯，新兵营的教官，作为格力沙的好朋友，一开始是不想让艾伦当兵的，因为他知道这小子以后肯定要当调查兵，那大家给艾伦起的外号“急着送死的混蛋”岂不是成真的了，于是他故意弄坏了艾伦的腰带，想让艾伦知难而退，但是艾伦的意志真的太强了，可以用百折不挠来形容，后来好不容易怀疑人生的时候，又被莱纳鼓舞了，这下更不得了了，基斯看到这种情况，也不得不放弃用坏掉的腰带逼退艾伦。</p><p>在马莱吊车尾的莱纳转身一变成了最可靠的人，莱纳在作品的前期其实是像艾伦大哥一样的存在，或者这样说，莱纳，吉克，都是艾伦的哥哥，莱纳是那种不是血缘关系，胜似血缘关系的大哥，吉克就是同父异母的亲兄弟。莱纳多次鼓舞艾伦，并且在基斯故意弄坏艾伦的腰带的那一次，给了艾伦很大的动力，另一方面，莱纳也是把艾伦当作了一个重要的角色，这个角色助长了他的精神分裂，让他更快的适应了士兵身份。</p><p>莱纳分裂出了两个人格</p><blockquote><p>战士人格，就是那个马莱战士铠之巨人莱纳<br>士兵人格，就是那个艾伦的好大哥，靠谱的莱纳。</p></blockquote><p>因为他在士兵人格的时候实在是太投入了，当阿妮某天和他说“如果再次撞墙，你的朋友们会死的。”的时候，转变为战士人格的莱纳竟然说，“他们不是朋友，是恶魔”，阿妮瞬间就感觉到了厌恶，“你能离我远一点吗？”</p><p>贝尔托特暗恋阿妮，平时沉默寡言，和莱纳形影不离，一副很没有主见，软弱的样子。</p><p>让喜欢三笠，非常嫉妒艾伦，也经常和艾伦吵架，他和马尔科是好朋友，他们的理想都是加入宪兵团过舒服日子，马尔科有一定指挥能力，人缘特别的好，情商也挺高的，他的眼里让也是一个指挥的人才。</p><p>萨沙和康尼家乡很近，萨沙以前经常打猎，非常喜欢吃，尤其是肉，在第一次出场就在偷吃白薯，哦不，是光明正大的当着所有人的面吃，被教官质问后竟然想分给教官一小半收买教官，结果被惩罚长跑，并错过了晚饭，康尼有点单细胞，一根筋，却有一些小聪明，很喜欢和萨沙在一起，他说他和萨沙就像是双胞胎一样。</p><p>赫里斯塔表现出了她的善良，加上长得也很美，被称之为女神，她为被惩罚而错过了晚饭的萨沙留了食物和水，被尤弥尔称之为烂好人，实际上这两个挺有趣的，从后面来看，表面温顺的女神是叛逆的“坏孩子”，表面狂野，放荡不羁的尤弥尔才是烂好人，这两个人，是一辈子的朋友。</p><p>5年时光一瞬而逝，新兵训练结束，大家要各奔前程了，这个时候有三个选择，排名越靠前的，可选择的越多。墙内的兵团分为三类。</p><p>代表自由的调查兵团，标志是一对翅膀的盾牌，这个调查兵团是以探索巨人秘密而存在的，这是个高危兵种，弄不好马革裹尸都是奢望。</p><blockquote><p>也有说法是为了肃清那些想要去墙外的异类而准备的兵种，当然这算阴谋论，<br>自由之翼由一黑一白组成，有可能是对于后期调查兵团分裂为韩派和耶派的暗喻，代表了韩吉和弗爵爷的针锋相对，灵感来自于另一个评论区里的朋友</p></blockquote><p>维护城墙的驻扎兵团，标志是一枚玫瑰花，守卫王城的宪兵团，在希纳墙内，最安全，待遇最好，有肉吃，还舒服的地方，萨沙和康尼也想去，目的是光宗耀祖。中央宪兵团是暗势力，就不说了。</p><p>艾伦是一定要去调查兵团的，三笠，阿尔敏都会跟随，让和马尔科要去宪兵团，阿妮要去宪兵团。</p><p>在分别的前夕，调查兵团出墙去探索，这个时候兵长已经成人类一哥了，艾伦他们在托斯特洛区（罗塞之墙的南部瓮城）的城墙上整理军用设备，就在萨沙说她顺了一大块肉，表示和大家一起吃，大家也同意的时候，随着一道闪电，超大型巨人突然在艾伦的背后出现。</p><p>超大型巨人出现带来的气流导致一个新兵掉下了墙，这个新兵叫山姆耶尔，被萨沙所救。</p><p>超大型巨人先是把墙上所有的固定炮摧毁了，然后像五年前一样，再次踢破了城门，艾伦回想起了五年前的场景，愤怒的持刀砍去，结果超大型巨人竟然凭空消失了。（这是超大人巨人的专属能力，神出鬼没）</p><p>巨人年850年，托斯特洛区城门破碎。</p><p>和上次一样，无数的无垢巨人从破碎的城门外进入托斯特洛区，在艾伦的鼓动下，所有人都在对巨人的恐惧中回过神来，开始了战斗。在补给区，三笠要求跟随艾伦，听闻三笠大名的长官前来调动三笠的时候，三笠甚至还想着找借口留在艾伦身边，却被艾伦狠狠的呵斥了一顿，三笠在不舍中离去。</p><p>艾伦在离开的时候又遇见了让，两人争吵一番暂且不提，艾伦信心满满的来到房屋上，准备讨伐巨人，然而队友托马斯，让的老乡，出身未捷身先死，被一只奇行种给吞了，艾伦此刻好像被引线点燃了心脏，直接炸了，疯狂的使用立体机动冲了过去，然后一顿操作猛如虎，结果腿被巨人啃了，说实在的当年看的时候我十分震惊，没想到艾伦的腿竟然没了，我还在想，第五集主角腿都没了，后面怎么演阿，结果马上，艾伦就被巨人吃了…</p><p>事情是这样的，艾伦断腿之后，同行的小队也团灭了，包括米娜在内的小队成员，全部被巨人杀害，只剩下吓的一动不动的阿尔敏还傻站在房顶上，这时，那个外号叫达尔文，也有叫他圣诞老人的巨人来了，一把拎起阿尔敏就要吃，却在马上得手的时候被艾伦阻止了，艾伦救了阿尔敏，取而代之被达尔文吞进肚子里，悲痛的阿尔敏亲眼看着这个一起长大的朋友消失在了这个世界上。</p><p>当时看的时候我无比震撼，心里都开始盘算主角要换成谁了…然后，我又被打脸了</p><p>在艾伦被吞下之后，三笠好像有了反应，回头看着艾伦的方向…</p><p>阿尔敏在看到艾伦被吞下后，心态整个崩了，又目睹了其他士兵的惨死，还有那对以秀恩爱著称的情侣，汉哪和汉哪的男友，阴阳两隔以后，失去了思考能力。</p><p>在另一边，三笠看到了商会的货物堵住了罗塞之墙的门，老百姓都不能过去，会长嚣张的命令着民众，并说自己是商会会长，如何如何，这时，有一只奇行种飞奔而来，奔着一对母女就来了，三笠干净利落的杀了这头巨人，民众一片欢呼。</p><p>会长还想教三笠做事，但马上就被三笠的作风给吓住了，连忙挪开了货物，让百姓先通过，这个被救的褐色的头发小女孩崇拜的看着三笠，多年以后，她也加入了兵团，视三笠为人生偶像，然而，命运弄人阿…</p><p>三笠在其他人口中得知了艾伦死亡了，表面平静的她已经心如死灰了，她指挥着立体机动装置中瓦斯不足的众人突围去补给班所在的塔楼，自己却自暴自弃，在杀了几只巨人后摔在了地上，她开始回忆起和艾伦相处的的点点滴滴。</p><p>生存的本能，让她躲过了巨人的几次攻击，但还是被逼近了，绝境，她的面前静静地躺着一个石榴…</p><blockquote><p>石榴，有代表重获新生的含义</p></blockquote><p>正在她被两个巨人夹击，以为自己就快要死了的时候，她突然发现，一个奇怪的巨人，竟然无视了她，挥拳向另一个巨人打去。攻击另一个巨人的，是一个长的很特别的巨人，这个巨人有着精灵的耳朵，身材修长，还有腹肌，这是一个15米级的巨人。在三笠正懵的时候，阿尔敏和康尼来了，阿尔敏带着三笠离开了这个是非之地，在到达安全的位置之后，阿尔敏交换了自己和三笠的瓦斯，希望三笠能够带领着大家活下去，但是康尼和三笠不愿意放弃阿尔敏。 一阵头脑风暴过后，阿尔敏的超高智慧体现了出来，他观察到了，这个奇怪的长着精灵耳朵的巨人只攻击巨人，而对他们是视而不见的，这样他们可以引导这个巨人，让这个巨人帮助他们清理路上遇见的巨人。</p><blockquote><p>这个巨人，被他们认为是一个奇行种。</p></blockquote><p>另外一边，让成了临场指挥，指挥大家冲入补给楼，但是只有少数的几个人跟着他突围成功了，为此，让十分的懊恼，正在这时，两个巨人打破了楼的窗户，在外面看着他，让绝望的认为，人类是不可能打败巨人的！但是马上，这两个巨人却被那个精灵耳朵巨人给打飞了，三笠，阿尔敏，康尼趁机来到了楼里。在这个楼里，阿尔明制定了一个作战计划去清理楼里徘徊的三四米的小型巨人，计划就是七个士兵拿着枪在天花板升降梯上吸引巨人，另外七个人，三笠，莱纳，贝尔托特，康尼，萨沙等，找机会去杀了这七个巨人，在这个过程中，康尼失误了，被阿妮所救。在填充瓦斯的时候，马尔科给让打气，称让的指挥是很了不起的，自己也希望在让的指挥下行动，这个谈话鼓舞了让，也是马尔科最后一次和让的谈心了。</p><p>第二天，所有补给完的士兵在城墙上与总队会和，大家发现了这个精灵耳朵巨人已经快油尽灯枯了，在他拼劲最后的力气咬死了杀害托马斯的巨人之后，他倒在了地上，艾伦在他的后颈处破体而出，这是艾伦第一次变身进击的巨人</p><blockquote><p>巨人继承者第一次变身为智慧巨人，都会出现暴走状态，除了贝尔托特，他第一次变身就熟练的掌握了超大型巨人</p></blockquote><p>在城楼上看着的人每个人心理想法都不一样，莱纳三人震惊了，产生了要俘获艾伦的想法，三笠激动的飞奔了过去，其他人也是欣喜若狂。时间回到前一天，达尔文巨人在吞食艾伦时，因为艾伦的挣扎，他没能咬碎艾伦的身体吸收脊髓液，也就导致了绝望的艾伦在他的身体中变身为进击的巨人，而他自己爆体而亡。</p><p>当艾伦悠悠的醒来之后，发现前来支援的驻扎军团正把枪口，炮口对准自己的方向，大家已经把他当成了怪物，而在自己的面前，站着的是三笠和阿尔敏，艾伦这个时候都不知道发生了什么，但是回想起了父亲给自己注射脊髓液时的记忆，陷入回忆中的艾伦进入了走火入魔状态，还说出了类似“把他们全部杀死”这类的话并露出陶醉的表情，而对面的驻扎军团长官，是之前负责指挥补给楼的一个大胡子，这个大胡子是个贪生怕死之徒，他下令炮轰艾伦，艾伦为了保护三笠和阿尔敏，变成了不完整的巨人，挡住了炮轰。</p><p>这个时候艾伦提议让三笠和阿尔敏离开，自己变成巨人逃跑，但是阿尔敏提出了另一个方案，在驻扎军团的枪口之前，他战胜胆怯发表了一个演讲，试图说服大家，他摆出献出心脏的姿势，大声的喊着，艾伦不是怪物，而是人类的希望，请大家相信他们，给他们一个机会！</p><p>但是大胡子不吃这一套，正准备下令呢，皮克希斯司令来了。皮克希斯，和奈尔，埃尔文同为墙内三大军团的首领，统领着南部地区的驻扎军团，是个酒鬼，更是个老狐狸，原型是秋山好古。</p><p>皮克希斯选择相信艾伦，并且采用阿尔敏的策略，想要用巨石堵住失守的城门。</p><p>但是要采取行动，首先要说服士兵，司令在城墙上宣布要进行堵门行动，并宣称艾伦是政府研究的巨人产物，但是士兵们不相信，心想你这是上坟烧报纸，糊弄鬼呢不是吗？纷纷表示就算是要死，也要和家人死在一起，司令马上又来了一段不亚于埃尔文的演讲，大致内容是想走的人就走吧，然后在恐惧里和要守护的人一起下地狱就好了，不想窝窝囊囊的死的，就来和巨人作战吧！</p><p>在司令激昂的演讲之后，士兵们决定背水一战，在司令的调动下开始了堵门行动，在这个过程中，并不顺利，因为变身后的艾伦竟然再次失控了，还差点伤害了三笠，就连驻扎兵团的临场指挥都觉得艾伦不靠谱，想要找到司令停止行动。</p><p>驻扎兵团的伊安，里柯，三笠，是负责保护艾伦的，但是三笠却差点为变身后的艾伦所杀，因为变身后的艾伦竟然失控，直接冲着三笠打了一拳。正在大家不知所措的时候，阿尔敏来到了进击的巨人身上，刺穿了巨人的皮肤，和艾伦谈话，讲那个他们约定好了的，关于看海的梦想，在幻境里的艾伦听到了阿尔敏的呼唤，恢复了意识，开始了堵门行动。</p><p>在这个过程中非常的惨烈，为了吸引巨人，保护艾伦，驻扎军团的一些老将甚至放弃了立体机动装置，在地面上大叫着吸引巨人的注意力，最后，包括伊安在内的一大批驻扎兵团成员阵亡，用自己的生命，换来了堵门成功。同一时间，康尼和让等人在进行引诱作战，过程中康尼的立体机动装置坏了，让救了他，然后让的立体机动装置也出了问题，在躲了一阵后修好了装置，再次使用的时候又被奇行种盯上了，幸运的是阿妮出现了，救了让让子。</p><p>在让获救后不久，城市的某个角落，莱纳等人在讨论到底怎么行动，莱纳表示了门被堵上实在是太可惜了，要是艾伦在堵门行动中被无垢巨人吃了那就更被糟糕了，又说了变成巨人等等言论，却被身后的马尔科听见了，马尔科大声的问他们在说什么，莱纳和贝尔托特扭过头，神色复杂的看着马尔科，马尔科后背发冷，忽然觉得很不对劲，莱纳这个时候想了个蹩脚的理由来搪塞，马尔科又不傻，他就找借口扭头跑了，但是被转变成战士人格的莱纳使用立体机动装置追上，并控制住了，这个时候不明真相的阿妮也来到了莱纳等人的身边，莱纳勒令阿妮夺取了马尔科的立体机动装置，这个过程中，刚刚赶到现场的阿妮非常的恐惧且内疚，由此可见阿妮这个人呢，结合她后来的所作所为来看，她确实漠视生命，可以残酷的杀害调查兵团士兵，包括了佩妹在内的利威尔班，但是对身边的人还是有感情的。</p><p>马尔科向阿妮求救过，但是，关于你他们三个人的秘密实在是太致命了，阿妮只能痛苦的离开，任由马尔科被巨人吞食。在莱纳等人干了坏事离开之后，马尔科绝望的喊道，“我们甚至还没有好好的谈一谈啊！”，然后就被巨人抓住咬了，在不远处的莱纳又回到了士兵人格，在那里自言自语，“喂，马尔科怎么被吃了啊…”很久以后，在让的追问下才知道，莱纳当时还愤怒的击杀了咬死马尔科的巨人，也是因为这次事件，阿妮和贝尔托特彻底的明白了，莱纳精分了。而马尔科这个很有大智慧的新兵，也以死亡宣告了自己的结局，并因此改变了让的一生。</p><blockquote><p>在作者的心目中，马尔科的智力在新生代也是很高的，艾伦莱纳他们这一代人中，阿尔敏和马莱的皮克应该是智商最高的两个人，马尔科紧随其后，也是个不可多得的人才，如果他活着，以后也会成为一个优秀的指挥官。</p></blockquote><p>在堵门成功之后，兵长等人从壁外赶了回来，瓮城内开始清理残局，其中调查兵团还捕获了两只巨人，一只7米，一只4米，调查军团的韩吉起名为索尼，和宾。这个韩吉是这一届调查兵团的元老了，是个巨人学大拿（仅限岛内，但是皮克妹妹在后来也亲自认证了），并且对巨人有着病态的热爱，他有一个副官叫做莫布里克，对她忠心耿耿，总是担心她的安危（八卦一下，这个小莫是调查兵团的酒量第一人，而韩吉的性别jsc是没有交代的，只表示了韩吉的性别就是韩吉）</p><p>这次堵门行动，是墙内世界认知里的，人类第一次正面打败巨人，以牺牲，失踪207名士兵，伤员897人为代价，获得的惨痛的胜利。在调查死亡人员时，让看到了死去的马尔科，这对他造成了巨大的打击。</p><p>萨沙等人发现了被吞食后又突出的球形物，里面包裹着的是人类的残骸，因为巨人没有消化系统，每次都是咬死人类，吞食后再吐出来，而达尔文呢，没能咬死艾伦就吞下去了，如果当时他咬了，现在也许是另一个故事吧。</p><blockquote><p>不为人知的角落里，阿妮对着自己好朋友，米娜的尸体，眼神呆滞的不停道歉，对不起…对不起…对不起…</p></blockquote><p>在调查兵团内部，韩吉对索尼和宾进行着各种实验，其中得到的情报就是巨人在夜间将会进入到迟缓的状态，但是进入状态的时间不同，也受月光的影响。另一边在地下监狱里，艾伦被关了起来，团长和兵长来找到艾伦，确认两件事，第一件事就是阿尔敏演讲的时候说的关于艾伦家地下室的问题，第二件事就是探寻艾伦的决心，在听到艾伦的“把巨人一匹不剩的驱逐”的想法之后，团长离开了。</p><p>在政府高层，大家对于艾伦的处理有很大异议，宪兵团想要拿艾伦做实验，或者杀死，调查军团肯定是不同意的，所以开了一个审判大会，用来判决艾伦到底何去何从，在法庭上，利威尔贡献了名场面，当着包括三笠在内的一行人的面踢艾伦，这个行为表达的意思是，这个人是可以变成巨人的，你们就不害怕吗，除了我利威尔能制服他，你们谁能？劳资是人类一哥，能人本事大，你们这些菜鸟呢？</p><p>也因为这个三笠对兵长不满了很久，还称利威尔为嚣张的矮子。</p><p>在艾伦和兵长的周瑜打黄盖的表演之下，宪兵团的头子奈尔也后怕了，大总统宣判艾伦由利威尔兵长负责监管，艾伦回到调查军团，并成为了调查士兵。韩吉对艾伦特别的感兴趣，某天，和艾伦聊了一夜的巨人，第二天却被士兵告知，索尼和宾被人杀了，有人看见凶手是用立体机动装置逃脱的，大家都想到了有内鬼。然后团长拍着艾伦的肩膀问艾伦，看到这个想到了什么，艾伦一脸懵，答不上来，团长说句对不起就离开了。在调查内鬼的过程中，所有人的立体机动装置都被检查了，阿尔敏观察到了阿妮使用的是马尔科的立体机动装置，但是他没有和别人说，也是因为他没有说也没有问，间接的导致了后面的惨剧的发生。</p><blockquote><p>推测，阿妮拿了马尔科的立体机动装置，并且她带在身边，她杀死索尼和宾的时候用的是一套，而回来之后用的是另外一套。</p></blockquote><p>现在时间到了新兵选择兵团的时候了，前十名的学霸可以申请北大青鸟，开玩笑，前十名的新兵可以申请宪兵团，但是主角团这里，除了阿妮去了宪兵团，所有人都来到了调查兵团，这个场景可以看动漫，很燃。</p><blockquote><p>bam：call your name</p></blockquote><p>三笠是毫不犹豫的加入了调查兵团的，阿尔敏紧随两位挚友，赫里斯塔有着自己的想法，也加入了调查兵团，尤弥尔跟随着赫里斯塔。</p><blockquote><p>希斯特里亚本人是一个有着悲惨童年的人，这也导致了她对自己命运的悲观以及对别人的认同的渴望， 因为她自己的母亲从来都没有认同过自己，出于这个心理，她总是想要用大义的理由来献出自己的生命，比如，在雪山里，为了救达兹，她居然自己拖着达兹行动，甚至不向一旁的尤弥尔求助。而尤弥尔，早就看出了她的想法，并在那一次和希斯特里亚做了一个约定，如果某天自己要暴露自己的秘密的时候，希望希斯特里亚也能用自己的名字勇敢的生活下去。尤弥尔早就看出了希斯特里亚不是表面上的女神，骨子里其实是一个“坏孩子”，而她自己，在希斯特里亚的眼里，也不是一个女汉子，而是一个彻彻底底的烂好人。</p></blockquote><p>康尼和萨沙也加入了调查兵团，二人一方面是受了之前在毕业party上艾伦的演讲的鼓舞，当时艾伦发表了“能力强的人都去了宪兵团，很滑稽”之类的演讲，还和让发生了争吵，但是这个演讲可能打动了萨沙和康尼，再加上托斯特洛区一战，两人下定了决心要和巨人战斗，于是加入了调查兵团。而让，是受了马尔科的影响，他挣扎了很久，还是选择放弃舒适的生活，选择了和巨人战斗，从这一刻开始，让成熟了，他再也不是以前那个有点少爷气，有点小骄傲，又喜欢找人吵架的让了。</p><p>104期加入调查兵团，对于调查兵团来说是补充了新鲜的血液，在这里，大家帮兵长打扫卫生…艾伦住在了地下室，因为怕他是会突然变成巨人会对大家造成影响。调查兵团开启了新一轮的调查，表面上是壁外调查，其实是团长的布局。</p><p>在这里，团长拿出了他发明的长距离搜索矩阵，大概意思就出发后所有人分散成三角形的阵容，通过信号枪的颜色来联系，由此避开路上可能遇到的危险。团长给了每个人一张阵型图，每个人的阵型图都是不一样的， 但是他们彼此之间不知道，不一样的地方，就是艾伦存在的地点。</p><p>是的，团长是在钓鱼执法，在听说了巨人是人变的之后，他迅速的判断出了铠甲巨人和超大巨人也是人变的，并且很可能就潜伏在军团之中，再加上索尼和宾的死，让这个可能性再次加大，所以，他制作了巨人捕捉计划，这是一场豪赌，没错，进击的巨人前期的剧情，就是团长的一次又一次豪赌推动的，且几乎每次都为岛内争取了极大的利益。</p><p>在行动开始之后，艾伦和利威尔班，就是包括佩托拉在内的四个人（这一段我尽量简略，因为这一段太悲壮了，如果要写能写几万字，大家还是重温动画比较好，真的感人）在一起行动，而小明他们在其他的位置上，本来行动一切顺利，但是阿妮从希纳之墙中溜了出来，当天她是让室友希琪给自己请假的。</p><p>阿妮变成了女巨人，来寻找艾伦，并且一边找一边残杀着调查兵团的士兵，其间，他找到了阿尔敏，阿妮把阿尔敏的马震飞，在落地的阿尔敏后面，掀开了阿尔敏的罩头，然后扭头跑了，阿尔敏一下子就意识到了这个女巨人在找人，一顿头脑风暴过后，他竟然推断出了女巨人是阿妮，但是当时他没有和身边的莱纳说，只是说了艾伦的位置在每个人的阵型图上可能都是不一样的，莱纳趁机套话问他艾伦可能在哪，阿尔敏毫无戒心，说了艾伦可能在中央后面的位置，然后又推论了女巨人的继承者可能是他们认识的人。</p><blockquote><p>推断，在这里感觉莱纳都慌了，如果不是让马上出现在了他们的身后，我怀疑他都要杀了阿尔敏灭口。</p></blockquote><p>然后女巨人再次出现，阿尔敏要求他们带上帽衫，这样女巨人就不知道谁是艾伦，就不会下死手，莱纳却趁机摘了帽衫，假装被阿妮抓住，并逃脱，实际给阿妮传递了艾伦的情报。一路上，女巨人杀人无数，杀的都是有经验的老兵，又是踢又是踩，又是人肉溜溜球的，极其的残忍，她很快的找到了艾伦，并且距离很近，在这里，艾伦想要变身，被佩妹阻止，艾伦问兵长该怎么办，有过因为相信队友而失去队友的经历的兵长说，你想做就做吧，他也不知道怎么才是对的，没有绝对不后悔的选择。最后艾伦选择相信利威尔班，不变身，女巨人被团长等人捕获，但是在兵长恐吓女巨人的时候，女巨人发动了技能咆哮，吸引了大量无垢巨人，无垢巨人啃食了女巨人，阿妮趁机用立体机动逃跑了。</p><blockquote><p>情报：女巨人可以通过吞食其他智慧巨人的一部分，来获得他们的小部分能力，比如这个吼叫技能就和吉克有点关系，硬化和铠甲巨人有关。</p></blockquote><p>阿妮逃离后又在另一边发射集合的信号弹，引诱了利威尔班前来，并再次变身女巨人团灭了他们，佩妹等人惨死，愤怒的艾伦变身为巨人，和阿妮决一死战。</p><blockquote><p>个人认为，这里是一个非常关键的转折点，因为这一次艾伦的选择相信同伴，选择相信利威尔班，所以导致了佩妹等人的惨死，这对他产生了巨大的心理阴影。<br>所以在后面的地鸣篇，他选择了独自面对一切，不再让队友承担风险，尤其是三笠和阿尔敏，他还故意的刺激他们，以让他们远离自己。<br>话说回来，佩妹等人其实吃亏在情报不足了，他们四个人是很强的，如果掌握了女巨人的能力情报，未必会输。</p></blockquote><p>艾伦在与阿妮的战斗中，发现了女巨人和阿妮的格斗技巧很像，但没来得及多想就被女巨人一脚踢掉了脑袋。女巨人含着艾伦逃跑了，赶来的三笠已经进入了怒火攻心的的状态，还差点被女巨人杀掉，兵长救了她一命，但也因此扭伤了脚。两个人追赶上了女巨人，女巨人被兵长的小陀螺刀法秒杀，因为体力，和受伤的原因，兵长和三笠带着艾伦回去了，没有选择继续对付女巨人，而在背后，女巨人在无声的哭泣。</p><blockquote><p>这一战，调查兵团铩羽而归，在回来的途中，两个士兵为了夺回朋友的尸体，引来了奇行种，导致了调查兵团要卸重前行，佩妹的遗体因此留在了墙外，成了很多观众心里的痛，佩妹之死，尸体遗落，佩妹的父亲和兵长的对话，简直就是第一季最大的催泪弹了。</p></blockquote><p>在回来的路上，艾伦发现了一男一女两个小孩，小男孩正在兴奋的看着调查兵团，和当年的自己多么的像啊… 在调查兵团的地下室里，阿明推断了女巨人就是阿妮，艾伦还不信呢，然后三笠也提出了女巨人就是阿妮，为啥，因为长得像…</p><blockquote><p>在104期新兵训练的某天，阿妮照旧把艾伦按在地上摩擦，黑脸的三笠把莱纳摔向了阿妮，阿妮敏捷的躲开了，三笠面无表情的说，阿妮，也请你教教我格斗术吧，阿妮冷笑着说，这个可是用来对付野兽的呀，然后大家迅速围观吃瓜，赌三笠和阿妮谁能赢…结果呢，结果是艾伦不记得结果了。</p></blockquote><p>在回到墙内之后，主角团分成了两波，萨沙康尼他们一波，艾伦三笠阿尔敏跟着调查兵团主力去捕捉阿妮，这也是团长的布局，团长认为女巨人一定有同伙，且很可能在104期这些新兵里，所以就让米可带走了莱纳这些人，并解除了他们的装备，算是变向的监视。</p><p>在宪兵团的地盘上，阿尔敏，艾伦，三笠假装要跑路，请阿妮帮忙，但是阿妮一眼就看穿了怎么回事，带上了父亲送给她的能弹出尖刺的戒指，在四个人即将进入地下的时候，阿妮拒绝了，阿妮和三人组进行了交谈，但谈崩了，阿尔敏说阿妮是个好人，阿妮却疯狂的大笑，指出了阿尔敏手握信号枪这一事实，看出了不对劲，一堆便衣跑了过来控制阿妮，但是阿妮使用了那枚戒指划破了手指，变成巨人，三个人躲进地下。</p><p>在三笠和阿尔敏的争取时间之下，艾伦克服了心理障碍，变成了巨人，和阿妮在城市中产生了战斗，死了很多无辜的平民，教堂中的教徒在祈祷中去了天堂，幸存的小女孩无神的在街道上走着。最后，在大家的围攻下，阿妮败了，在想要逃跑的时候，被三笠所制止，暴走的艾伦想要吞食阿妮，但是阿妮却使用了水晶化，就是本体封锁在一个巨大的水晶中，这个能力应该是从战锤巨人那里获得的。</p><blockquote><p>在帕拉迪岛，没有任何东西可以损坏这个水晶，就像三体里水滴来袭时，太阳系没有任何一个物质能够打坏强物质组成的水滴一样。<br>而战斗过后，韩吉等人震惊的发现，破碎的城墙里，竟然露出了一只巨人的眼睛，在这个时候，尼克神父赶来，要求兵团赶紧遮住城墙的漏洞，不能让巨人看到阳光。</p></blockquote><p>尼克神父属于壁教，这个壁教是墙内的一个教会，实际上是知道巨人之墙的秘密的，尼克就知道，他们表面上鼓动教徒要热爱墙壁，好像一个个墙壁痴汉，把墙壁当作是神，但其实是为了保护墙壁的秘密不为人所知，可以当作是一个情报组织。</p><p>韩吉为此威逼利诱尼克，但尼克却宁死不屈，调查兵团想要获得情报，却遇到了瓶颈。韩吉为此威逼利诱尼克，但尼克却宁死不屈，调查兵团想要获得情报，却遇到了瓶颈。但是韩吉发现了女巨人的硬质化的碎片的结构和城墙是很像的。后来尼克虽然不肯说出真相，但还是指出了一个秘密，就是赫里斯塔的身世，尼克说，赫里斯塔身上有真相。主角团的另一部分人被怀疑有着阿妮的同伙，而被卸掉了武器，调往罗塞之墙的南部，米可负责监视。然而他们却遇到了新的难题，罗塞之墙内部突然了巨人，这个是萨沙先发现的，猎户的直觉让她留意到了巨人的脚步声，于是大家分散开来疏散群众，米可派人和军队报信后断后。康尼回到了自己的家乡，发现了村子里的人不见了，自己家上躺着一个无法动弹的巨人，会说欢迎回家，看上去很像自己的母亲。</p><p>萨沙回到了自己的家里，并且在一个房子里救了一个母亲正在被巨人吞噬，自己却吓傻了的小女孩，在武器不足的情况下，萨沙用几只弓箭和一只弓，以及自己的战斗经验，搞定了巨人，成了乡亲们口中乐于称道的少女英雄。但是，负责断后的米可遇到了麻烦，他在清理了几个巨人之后不幸的遇到了吉克，吉克操纵猴子捡起了他的马，冲他扔了过来，在米可失去了战斗能力后，吉克还想询问他一些岛上的事，米可一句话也说不出来，吉克对立体机动装置很感兴趣，就是这个时候，他发现了立体机动装置中的冰爆石，并以这个情报拉拢了东洋人，这是后话。吉克看问不出来什么，就杀了米可。</p><p>罗塞之墙内，得到了米可的情报的三大军团出动，另一边，莱纳，赫里斯塔等人被围困在一个古堡里，在这里，大家被吉克召唤的巨人围攻，莱纳和贝尔托特看到吉克战士长非常的激动，在这之前，莱纳击退了巨人，还被巨人咬了一口，救了康尼一命，这是莱纳不多见的高光时刻，在保护他们的老兵纳拿巴等人牺牲之后，尤弥尔决定保护赫里斯塔，变成了巨人和无垢巨人们战斗。</p><p>在古堡倒塌之后，艾伦等人赶来，他们来之前，已经锁定了莱纳和贝尔托特是铠甲巨人和超大型巨人，当时在锁定了阿妮之后，调查兵团翻看了104期新兵的资料，加上大家的推断，除了艾伦之外的人都锁定了莱纳和贝尔托特。为了不打草惊蛇，韩吉等人决定把莱纳和贝尔托特带到可控制的地方进行抓捕，但是在城墙上，莱纳的精分犯了，并再次贡献了名场面。这个时候的莱纳大概分不清自己是士兵还是战士了，他直接和艾伦说，“我是铠甲巨人，他是超大型巨人，五年前我们破坏了墙壁，和我们走吧，这样我们就不用再破坏墙壁了。”</p><p>艾伦这个时候还觉得很荒唐，他已经有些确定了莱纳和贝尔托特的身份，但还是想以莱纳喝多了，不不不，莱纳累坏了为理由引诱莱纳，但是莱纳等不及了。背叛神曲响起！在千钧一发之际，三笠赶来，封喉了贝尔托特，砍伤了莱纳，在准备补刀的时候，被莱纳推开了，他们还是变身成功了。</p><p>铠甲巨人握着艾伦跳下了城墙，超大型巨人捉住了尤弥尔和另一个调查兵，并用蒸汽逼退了调查兵团。艾伦变身为进击的巨人，炸碎了莱纳的一只手，在城下和莱纳单挑，本来是劣势，但是运用上了阿妮教给他的格斗术之后，立刻就吊打了莱纳，但是千算万算，没算到超大型巨人竟然从城墙上掉落，给他砸晕了。</p><p>贝尔托特带着两套立体机动装置，拽上艾伦和尤弥尔，乘坐铠甲巨人离开了。又过了一阵子，团长等人到达了战场，收拢士兵，发动了追回艾伦计划。在巨木森林，莱纳和艾伦等人对话，尤弥尔在权衡利弊后，觉得岛内干不过马莱，就决定牺牲自己保赫里斯塔一命，莱纳也答应了，但是是想以后再说，尤弥尔不同意，说赫里斯塔马上就要来了，要现在动手，因为104尤弥尔的坚持，莱纳等人错过了逃跑的最佳时机，被调查兵团赶上了。在壁外，没有什么建筑物可供使用，追回艾伦是有难度的，但是团长竟然了选择使用吸引无垢巨人，来攻击莱纳等人的计划，这是个伤敌一千自损八百的狠招，在这个过程中，团长失去了自己的手臂。这一战，又是一场惨烈的战斗，艾伦和三笠也被困在一个小平地上，三笠在这里进行了隐晦的表白，艾伦也为三笠戴上了围巾，然后，奇行种黛娜出现了。</p><p>是的，那个吞食了艾伦的母亲的奇行种黛娜出现了，汉尼斯大叔选择报恩，和黛娜决一死战，却被黛娜反杀，愤怒的艾伦挡在了三笠面前，用拳头和黛娜进行最后的抵抗，却无心插柳柳成荫，艾伦接触到了王血巨人，触动了坐标，他控制无垢巨人击杀了黛娜，又围攻了莱纳，大家趁机离开。</p><blockquote><p>莱纳心里焦灼的不得了，他激动的想着，“竟然让那个天底下最不应该获得坐标的人获得了坐标！”</p></blockquote><p>这一战，艾伦成功被追回，但是尤弥尔仍旧选择了把颚之巨人还给马莱，所以她留了下来和莱纳，贝尔托特并肩作战，在看到了艾伦使用坐标之力后，她觉得岛上还有希望，就没有再带走赫里斯塔，这个时候的赫里斯塔，已经恢复了希斯特里亚的身份，两个人做了最后的告别。</p><p>这是烂好人和坏孩子的最后告别。</p><h2 id="王政篇"><a href="#王政篇" class="headerlink" title="王政篇"></a>王政篇</h2><p>在回到墙内后，清算开始了，贵族们要找埃尔文的麻烦，雷斯要夺回始祖巨人，于是指使肯尼和中央宪兵团去绑架艾伦和赫里斯塔，其中有一段商会会长的剧情，这个不太重要就不多说了，简单来说就是中央宪兵团先是让商会会长去绑架艾伦和希斯特里亚，以达到调虎离山的目的，然后他们自己再动手，并成功的挟持了艾伦和希斯特里亚，商会会长就是之前用货物堵门，但是被三笠命令给平民让路的那个。</p><p>假扮艾伦的是让，假扮希斯特里亚的是阿尔敏，阿尔敏还被绑匪猥亵了…肯尼和利威尔终于针锋相对了，在肯尼缜密的布局之下，利威尔依旧逃脱，甚至杀了他的很多手下，还差点杀了肯尼。调查兵团的众人抢夺艾伦和希斯特里亚失败，在和中央宪兵的战斗中，让因为犹豫差点被人开枪打死，而阿尔敏为了救让，杀了一个人，这一生第一次杀人。</p><p>雷斯带着希斯特里亚来到了他们家族的大本营，教堂下的地下室，在这里，他开始给希斯特里亚洗脑，希望希斯特里亚能够变成巨人，吞食艾伦，夺回始祖巨人，重振家族，而艾伦此时沉浸在父亲的记忆之中，看到父亲杀了罗德·雷斯的一家人，包括小孩，还有一些其他的记忆，他觉得自己罪孽深重，已经没有了求生意志。</p><blockquote><p>剧透一下，此时的他肯定想不到，格力沙之所以有勇气杀人，那是未来的自己通过进击的巨人的能力，影响了格力沙，也就是说，他自己为父亲杀人悲痛，但其实父亲的杀戮是未来的自己所教唆的。　<br>再说一下，雷斯当年为什么要保希斯特里亚，却又不敢违抗肯尼，当年雷斯家族除了他都团灭了，始祖巨人也丢了，这个情报只有他自己知道，他不敢告诉任何人，而肯尼是奉了贵族们的指令，来清理门户的，毕竟理论上雷斯家只能和这些贵族通婚，希斯特里亚属于私生女，是肮脏的血统，也是不光彩的，而雷斯接希斯特里亚母女的时候，刚好碰到了来清理门户的肯尼，如果他玩命的死保希斯特里亚，那么就会引起肯尼的怀疑，一旦大家发现始祖巨人没了，那还玩个啥啊。</p></blockquote><p>希斯特里亚差一点点就从了他爹的心意，但是最后的最后，还是选择做一个坏孩子。摔爹神曲起！希斯特里亚摔了脊髓液，并救了艾伦，地下室的另一头，肯尼一直在看戏，而罗德崩溃的舔舐着脊椎液，变成了奇行种。</p><p>兵长这边呢，带着三笠他们在背地里行动，他们发现了尼克神父的死亡，尼克曾经给过他们希斯特里亚就是答案的线索，兵长他们通过商会会长，骗来了中央宪兵团的两个人，就是这两个人严刑拷打了尼克神父，导致了尼克的惨死，在韩吉和兵长以其人之道还治其人之身后，一通酷刑下来，他们得到了一个情报，墙壁里的王只是个傀儡，雷斯家族才是真的掌权者。</p><p>于是兵长他们前往雷斯家了，路上还和西瓜头和希琪打了个照面，希琪是阿妮的室友，西瓜头是一个和艾伦很像，但是没有艾伦那么强的意志力的一个愣头青，是阿妮的同事，他曾看到长官在贩卖军用物资，自己阻止却被打了一顿，想要开枪又不敢，他问阿妮，“如果是你说的那个急着送死的家伙，他会这么做吗？”，当时心思沉重的阿妮给了肯定的回答。</p><p>再说团长那里，团长面对的是绞刑，但是团长竟然在背地里发动了政变，他先是给奈尔灌了迷魂汤，指出了奈尔的亲人至今还在罗塞之墙，不在希纳之墙这一点，奈尔的妻子最早是喜欢埃尔文的，但是因为不想丈夫早死，选择了嫁给奈尔， 当然也有可能是团长不想耽误她，奈尔非常爱自己的家人，团长在谈话中先给奈尔埋了一个怀疑的种子。</p><p>你以为你是权力中心？？？不，你并不是，你的家人都处在罗塞之墙，连进安全的希纳之墙的资格都没有。</p><p>奈尔在这之后开始疑神疑鬼，他注意到了中央宪兵团的存在，终于发现了贵族们有着巨大的秘密这一事实。而皮克希斯是主动来找埃尔文的，这个老狐狸圆滑的很，他是穿着便装来的，一来就试探埃尔文的筹码，团长丝毫不慌，先拿出艾伦，再拿出希斯特里亚，把皮克希斯的心拿捏的死死的，要知道，军队政变，也是要师出有名的，如果埃尔文拿不出像样的计划，皮克希斯会直接走人，而希斯特里亚和她的身世，就是最大的政变理由。于是，皮克希斯背地里又联络了墙内的隐藏艺术家，大总统弗雷兹，这个哥们对养尊处优的贵族很感兴趣，以至于非常想观察贵族成为rbq的样子，他也参与了政变。</p><blockquote><p>我说的是比较笼统的，但是实际上的团长发动政变，细节上还要更多一下，这个男人的政治天赋真的很强。</p></blockquote><p>于是，就发生了著名的无硝烟政变。团长被押送来和贵族们对峙，团长一顿嘴炮贵族压根招架不住，贵族就想让奈尔他们动手，但是这个时候，驻扎兵团的调查兵来了，谎称罗塞之墙被铠甲巨人和超大巨人攻破了！这一下子，奈尔直接慌了，他家人还在罗塞之墙呢。奈尔准备接收难民，贵族们却要求他关闭城墙，图穷匕见啊，奈尔和宪兵们终于见识到了，这群贵族到底是一群什么自私的玩意。于是，政变成功，大艺术家弗雷兹梦想成真，一切都向着好的方向发展了。在兵长那边，赶到雷斯家大本营的兵长等人和中央宪兵团打了起来，罗德·雷斯又变成了超级大的奇行种，多大呢，两个超大型巨人那么大，站不起来，只能爬。</p><p>调查军团的众人开始对付这个奇行种，最终，在它趴在城墙上的时候，艾伦变身巨人，快递炸弹炸碎了他的后脑，无数的后颈肉飞在天上，大家都意识到，斩草要除根，得找到有着罗德意识的那一块，不然巨人还会复活，然而命运就是这么的巧妙，是希斯特里亚开始了空中华尔兹，在一对肉块中精准的找到了她爹的那一块，并斩碎了，她成了救世主，并且顺利的成为了女王。</p><blockquote><p>情报：漫画里希斯特里亚是不愿意当女王的，因此兵长还揍了她一顿，作为报复，成为女王之后，在大家的忽悠之下，她还打了兵长一拳，小粉拳锤胳膊。</p></blockquote><p>在政变之后，团长快马加鞭，制定了夺回玛丽亚之墙计划，寻找艾伦家地下室的秘密。此时的玛丽亚之墙下，铠甲巨人被打的粉碎，吉克慢条斯理的说，“那么定好了，我们晚一点再救阿妮妹子。”而在希纳之墙的黄昏里，只剩下一口气的肯尼，告诉了兵长，他到底是谁，并且留给了兵长一剂巨人脊髓液。</p><h2 id="夺回玛丽亚之墙"><a href="#夺回玛丽亚之墙" class="headerlink" title="夺回玛丽亚之墙"></a>夺回玛丽亚之墙</h2><p>团长等人浩浩荡荡的出发，这一战，将是人类雪耻的一战，调查兵团出动了所有的力量，还动员了这一批的新兵，以及其他军团的人，西瓜头就在此列。然而他们想不到，虽然团长和阿尔敏等人已经做好了应对的准备，但还是会被敌人瓮中捉鳖，尤其是，不仅仅是吉克，莱纳，和贝尔托特三个人，马莱战士队的最佳辅助，智商担当皮克这次也来了，也就是说，马莱现在是只有新继承的颚之巨人这一个巨人的。在希甘希纳区，调查军团在阿尔敏的指挥下，迅速的找到了藏在城墙里的莱纳，但是却被吉克围堵在了希甘特纳区。希甘特纳区内，在阿尔敏的指挥下，大家迅速的发现了躲在城墙里的铠甲巨人，兵长甚至差一点杀了他，变身成铠甲巨人后，莱纳又被韩吉发明的雷枪炸个半死，彻底的耽误了之前他们制定的计划，另外一边，吉克站在希甘特纳区和玛丽亚之墙的门外，带着一堆巨人对着团长，兵长等人进行围攻，皮克负责运输石头，吉克则不停的投掷轰炸，并且把贝尔托特扔向了希甘特纳区。在希甘特纳区，贝尔托特找到了莱纳，并且和三笠打的有来有回，看来他的心态更偏向与战士方了，在安顿好莱纳之后，贝尔托特选择变身，炸死了很多人，贝尔托特想要到门那里，一方面获取艾伦，另一方面是为了团灭团长等人。艾伦操纵进击的巨人想要阻止，却被超大型巨人一脚踢飞，晕了过去。在这种绝境下，阿尔敏来到了艾伦身边，再一次用刀扎进巨人，把艾伦从昏迷中带了出来，两人计划击杀超大型巨人，然而艾伦不知道，阿尔敏的计划就是，牺牲自己，给艾伦创造机会。最后艾伦成功了，阿尔敏却被烧的只剩下了一口气。城市的另一个方向，莱纳被三笠等人用雷枪给炸了出来，在他的口袋里，发现了尤弥尔给希斯特里亚写的信。韩吉想要杀莱纳，却被让阻止了，让想让墙内获得铠甲巨人，权衡再三，韩吉让三笠去看看艾伦那里情况如何，三笠离开。</p><p>墙外，兵长等人正面对着吉克的轰炸，因为马无法通过废墟，所以大家回不去希甘希纳区，团长这个时候陷入了失落的情绪之中，他不知道该直接去艾伦的地下室，还是继续作战，并且把选择的机会交给了利威尔，利威尔则要他，带着新兵下地狱吧。于是，在生命的最后一段时光里，团长抛弃了自己的梦想，选择了大义，选择了，让那些献出心脏的同伴，看看他们献出的心脏怎么样了。团长开始了人生的最后一段演讲，并且带着新兵冲锋，用信号枪扰乱吉克的视线，而兵长趁机通过旁边站军姿的几个无垢巨人接近吉克。这场冲锋异常悲壮，很多人都知道，这是一场有去无回的冲锋。团长带着他的最后的荣光，倒在了吉克的碎石之下。西瓜头临死之前后悔了，他又想起了希琪，那个对他很不一般的女孩，他在想着，这个女人肯定又在睡懒觉吧，然而，希琪早就醒了，在静静的等着他回来…</p><p>在吉克正疑惑的时候，兵长来了，三下五除二的就斩杀了猴子巨人，兵长锁定猴子的后颈，猴子伸手来抓，兵长直接砍废猴子的胳膊，猴子赶紧捂住后颈，兵长却趁机砍断了猴子的跟腱，在他摔下来之前又砍碎了他的眼睛，最后他来不及硬质化就被兵长给拽了出来。他又回想起了，之前莱纳让他小心一个士兵，就是士兵长，利威尔，他还有些惊讶呢。兵长很想把他杀了，但是还是想找一个还有一口气的人，来吞食吉克，就在兵长犹豫的时候，皮克来了，趁机带着吉克跑了。墙内，赶来的皮克又救走了莱纳，但是在救贝尔托特的时候，被艾伦以刀架在贝尔托特脖子上的架势震住了，吉克认出了艾伦，并且和艾伦说，他被格力沙骗了，艾伦根本就不鸟他。车力巨人皮克带着重伤的吉克和半死不活的莱纳离开了。在墙内，兵长带来了巨人脊髓液，正准备给阿尔敏注射的时候，弗爵爷带着团长回来了。注意这个弗爵爷，这是个关键角色，他的名字叫弗洛克，弗爵爷是大家起的昵称，也有人喜欢叫他欧皇，因为他是唯一一个在吉克的轰炸之下，无伤回来的。兵长因此纠结了，因为埃尔文也还有一口气在。艾伦看到兵长犹豫了，想要去抢夺针管，却被兵长一脚把半口的牙都踹飞了。三笠恨的牙痒痒，直接用刀想杀了兵长，后来被韩吉拉住了。三笠和艾伦坚持救阿尔敏，弗爵爷坚持救团长，因为他觉得团长是那个可以带领他们的恶魔。最后大家让兵长选择。兵长思考了很久，想起了埃尔文的过往，又想起了自己偷听到的阿尔敏和艾伦他们神采飞扬的讨论外面的世界的对话。最后他还是选择了埃尔文，正准备打针的时候，埃尔文把手甩开了，原来是埃尔文在弥留之际回到了小时候，他在举手向老师提问，问那个纠结了大半生的关于巨人的问题。 最后，兵长选择了救阿尔敏。至于兵长为什么救阿尔敏，我只能认为，兵长认为埃尔文这么多年下来扮演恶魔，太累了，让他安息吧，未来就交给孩子们。韩吉成为新的调查兵团团长。众人如愿的来到了艾伦家的地下室，发现了格力沙留下的三个笔记本，里面描述了岛外的世界，众人终于，接触到了这世界最残酷的真相。岛外是有人的。岛外的人，都把他们当作是恶魔。</p><h2 id="海的那一边"><a href="#海的那一边" class="headerlink" title="海的那一边"></a>海的那一边</h2><p>巨人年851年，玛丽亚之墙夺回，艾伦等人成了大英雄，接受女王的封赏，在这个过程中，弗爵爷仍然表示不能接受救阿尔敏这件事，这也表示了，这个人是一个绝对一根筋的人，就像是之前他认为团长是唯一一个能带领他们的恶魔，他就眼里只有埃尔文，后来他觉得艾伦才是墙内艾尔迪亚人的希望，就只效忠艾伦，这是一个某种程度上来说，非常执着的人，如果在和平年代，他可能是一个很不错的少年吧。</p><p>在接受女王封赏的时候，艾伦触碰到了女王的手，接触到了王血后裔，艾伦获得了大量的记忆碎片，这是15伦转向19伦的重要节点。一年之后，玛丽亚之墙宣布清空所有巨人，调查兵团开始在墙外调查，和之前的推断一样，几乎所有的无垢巨人都在玛丽亚之墙之中，玛丽亚之墙清空，岛内的巨人也就不复存在了。艾伦和韩吉等人快马加鞭，终于，看到了梦寐以求的大海。在所有人在海水里嬉笑打闹的时候，艾伦指着海的另一边，说道，“海的那一边，有自由。”“我以前是这样想的。”“现在，是不是把海的另一边的敌人都杀了，我们能自由吗？”而艾伦没说的是。</p><p>“当得知海的对面还有人的时候，我，非常的失望！”</p><h2 id="暗潮涌动的四年，巨人年855-859年"><a href="#暗潮涌动的四年，巨人年855-859年" class="headerlink" title="暗潮涌动的四年，巨人年855-859年"></a>暗潮涌动的四年，巨人年855-859年</h2><p>讲马莱篇之前，讲一下艾伦和吉克这几年在干什么。在104尤弥尔到达马莱之后，她选择了把颚之巨人还给马莱，并在死之前，给希斯特里亚写了最后一封信，这封信后来通过莱纳，再通过韩吉，交给了女王，甚至女王通过王血的能力看到了尤弥尔生前的最后的画面。这算是对这一对挚友的友情，给了一个交代。墙外的各国得到了马莱国夺取始祖巨人失败，并且损失两名巨人的消息（走漏风声），与马莱国发动了战争，这一打，就是四年多，吉克，莱纳，皮克等人纷纷加入战争，这四年帕拉迪岛没有再被战士队骚扰，但是吉克还是建议马来政府，派舰队去探索帕拉迪岛，这里他表面是为马莱着想，其实是进行他自己的计划，这些开往帕拉迪岛的舰队，一艘都没有回来。</p><p>艾伦获得了未来的记忆了之后，他就变得沉默起来，他并没有和别人分享这一切，就像当初他和大家隐瞒了王血巨人可以控制坐标这件事，以保护希斯特里亚一样。艾伦和希斯特里亚，真的是一对蓝颜知己，两个人都背负着沉重的命运，在希斯特里亚被强盗绑架的时候，艾伦是第一个也是唯一一个坚持要去营救希斯特里亚的人。在希斯特里亚被雷斯洗脑的时候，她挣扎过后选择摔爹，来营救艾伦。这一次又轮到艾伦了，他找到了希斯特里亚，告诉了她自己的灭世计划，也是这个世界上，他唯一一个告诉的人。希斯特里亚很痛苦，她表示如果这么做，她将无法再抬头活下去了，艾伦最终说服了她，而希斯特里亚，也是主角团中唯一一个支持艾伦的人。</p><blockquote><p>艾伦：“毕竟，你是那个在地下室里救了我的，全世界最坏的孩子啊。”</p></blockquote><p>19伦在决定灭世之前，也是去世界各地看过的，甚至参加了那个什么尤弥尔子民拯救讨论大会，在大会上，他确认了世界各国仇视帕拉迪岛的事实，从而坚定了他灭世的决心。而他也给了帕拉迪岛几年的机会，等待阿尔敏和韩吉能拿来出一个拯救帕拉迪岛的方案，然而阿尔敏做不到，韩吉选择逃避。在马莱，吉克一直在搞他的马莱义勇军 ，这家伙和他爹当年的艾尔迪亚复兴派不同，他的最终计划是准备集体阉割艾尔迪亚人，从而达到安乐死的目的，这是一种自灭的行为，是对自己的民族失望透顶或者说觉得自己的民族太过罪恶而产生的心理，而造成这一心理的就是童年时代不停给他洗脑的格力沙和黛娜，他产生自我毁灭的心理，大概和叶文洁给三体星系发送地球坐标的心理类似。</p><p>吉克的计划无疑是受了库沙瓦的影响的，但是他自己把这个计划给完善了，在进击的巨人中，在搞阴谋这一块，吉克怕是要排老大了，团长的智谋和手段是巨人的top，吉克的野心和阴谋也是top。吉克的马莱义勇军是什么呢？是一个反马莱组织，成员多半是其他被马莱侵略的国家，比如那个黑人欧良果鹏。副统领伊莲娜视吉克为偶像，这个伊莲娜是个马莱人，但是却看不惯马莱的作风，于是假装成被马莱侵略的国家的人来参加马莱义勇军，她的思想就是乱世出枭雄，先和马莱义勇军占据帕拉迪岛，吉克再进行安乐死计划，这样，一百年后帕拉迪岛的艾尔迪亚人灭绝，他们就是主人了，看到没，人家多高明，欧洲人占据北美洲靠屠杀印第安人，他们直接兵不血刃就想反客为主了。在这4年里，马莱曾多次派军舰去帕拉迪岛，但都有去无回，没错，就是艾伦他们干的，每次都是在码头伏击，屡试不爽。</p><p>某一次，马莱义勇军装成马莱军人来到了帕岛，在韩吉等人又想灭口的时候，伊莲娜枪毙了马莱的军官，率领马莱义勇军投降了。在这一波人里，有一个马莱士兵叫尼克洛，投降了之后，他在岛上开了一家餐厅（帕拉迪岛对待投诚的俘虏待遇是很好的），萨沙是最积极的客户，在第一次吃尼克洛的料理的时候，萨沙称他为天才，这让尼克洛感到非常的温暖，这个尼克洛其实并不是喜欢战争的人，是萨沙让他重新找回了快乐，原来料理，也能帮一个人快乐呢。</p><blockquote><p>久而久之，尼克洛和萨沙，对彼此都有了特殊的情感。</p></blockquote><p>伊莲娜代表吉克，和韩吉达成了合作关系，吉克提出的条件是希望自己在任期到之前，能够登上帕拉迪岛，并且和艾伦见面，作为交换，他愿意帮助帕拉迪岛提升科技，帮助帕拉迪岛和一些友好的国家进行建交，并且进贡了一批红酒，而这批红酒里，掺了吉克的巨人脊髓液。</p><blockquote><p>变成巨人的方式有几种，注射巨人脊髓液是最直接的，还有吸取巨人脊髓液喷雾，虽然并不能立即变身，但是可以被野兽巨人的吼叫激活，变成巨人，红酒这个应该是和脊髓液喷雾差不多，属于给艾尔迪亚人埋了个引子，然后吉克在不远处吼叫就可以把他们变成无垢巨人了，康尼的家乡就是这么消失的，罗塞之墙里的巨人就是康尼家乡的人，因为康尼的母亲当时怀孕了，所以变身的不完整，只能卡在房子上。<br>这种吼叫变身的方法，是王血的能力，马莱的巨人学专家研究了很久，只能得出吉克血统特殊的结论，竟然不能推断出他是王血，真的是很废柴了。</p></blockquote><p>岛上的人对吉克这号人肯定是不信任的。</p><p>而吉克，预料到了岛上的人不会这么轻易的相信他，他和岛上的人保证，自己有一个绝妙的方法可以保证艾尔迪亚人的安全，虽然现在不能说，但是可以交代一下另外一件事，就是地鸣，自己有办法把城墙里的超大巨人放出来，以此威慑其他的国家，而他的不能说的计划，就是阉割计划，俗称安乐死，通过连接路里的尤弥尔，让所有的艾尔迪亚人失去生育能力，这就是赤裸裸的逆向民族主义，和民族主义的耶格尔派是两个极端。吉克还提出让别人来接替他的野兽巨人，并且在任期内尽可能的繁衍，这样，地鸣的威慑将会持续存在，岛内就安全了，事后来看，这个提议绝对是黄鼠狼给鸡拜年，大半是为了让岛内自己先产生争执。岛上的高层做出了决定，一方面，他们培养了始祖巨人的候补人选，另一方面，还预谋用女王来继承野兽巨人，在牺牲女王这一块，韩吉选择了默认，虽然她也很犹豫，甚至连女王自己都妥协了，准备现身，只有艾伦，还是只有艾伦一个人，提出了抗议。</p><p>猜测，这也是艾伦果断的同意了红酒战略的原因，岛上的高层压根就不可靠，死了就死了吧。</p><p>而希斯特里亚对抗岛内高层的方式，就是结婚生子，她火速的找到小时候冲她扔石头的那个放牛娃，那个男孩当年是喜欢希斯特里亚，为了吸引她的注意才这么做的，长大以后他沉默寡言，一直在女王开的孤儿院里工作。</p><blockquote><p>大家不要模仿这个放牛娃， 这家伙上辈子肯定是拯救了地球和三体两个文明的圣人。</p></blockquote><p>关于红酒，是吉克绕过韩吉，通过伊莲娜和艾伦达成的协议，让岛上的高官喝下酒，到时候趁机控制帕拉迪岛。与此同时，耶格尔派在军中出现，以弗爵爷为首，唯艾伦马首是瞻，艾伦和弗爵爷表明过自己的一些想法，并且交代了红酒的事情，现在可以看作弗爵爷是耶格尔派的头子，是帮艾伦办事的。也是因为吉克的原因，清美女士来到了帕拉迪岛。清美女士，是希兹尔国（日出国）的代表，是东洋人，她前来主要是因为冰爆石，还有三笠。之前吉克发现了立体机动装置里有冰爆石这种稀有资源，这东西全世界都少见，帕拉迪岛却很丰盛，因此和日出国达成了战略合作，但是日出国也没什么国际地位，属于弱小国家，但即便如此，科技也吊打帕拉迪岛了。清美女士和马莱义勇军这几年帮助帕拉迪岛建造了铁路，火车，港口，甚至后来还研究了冰爆石为动能使用的飞行机，就是最原始的那种双翼飞机。至于三笠呢，根据清美的说法，三笠的祖先是东洋的一个将军，在帕拉迪岛还尚未封闭的时候来到了岛上，后来145王洗脑，追杀岛外人士，三笠的祖先也没能回去，这个三笠的祖先也是清美的祖先，她们是同族同源。现在的局势就是，阿尔敏和韩吉各种摸鱼，艾伦和吉克相互试探，提防，又必须要合作。</p><p>而最大的行动，就是奇袭雷贝利欧，夺取战锤巨人。</p><p>在这之前，岛上的势力已经化成了几块，岛上的高层为首的保守派，培养人才准备接替艾伦，并且牺牲女王，接替吉克，这样岛上就拥有了地鸣的威慑力，俗称执剑。伊莲娜，欧良果鹏在内的马莱义勇军，表面上建设帕拉迪岛，实际上伊莲娜通过尼克洛，不断的把红酒扩散给岛内的高层（红酒这件事只有少量马莱义勇军知道，不包括欧良果鹏）。艾伦，自己是一个阵营。耶格尔派，为艾伦的行动扫清障碍，目前在潜伏。韩吉等人的调查兵团，目前他们是知道的最少的，他们这几年在海外各个国家都建立了据点，也为奇袭雷贝利欧提供了保障。伊莲娜主动要求皮克希斯监视自己，然后又趁着某次弗爵爷监视的时候，建议艾伦要给岛上的人来点“刺激”，现在太死气沉沉了，于是艾伦后来强迫调查兵团进行了奇袭雷贝利欧计划，这个计划是艾伦坚持的，利用的是调查兵团不能放弃艾伦的这一点。在这之前，艾伦和众人在韩吉的建议下去了岛外各国，原因是清美的东洋国做不到代替艾尔迪亚人发声。</p><blockquote><p>至于为什么做不到呢，第一，东洋国自己就是弱者，第二，他们想独吞冰爆石这个资源。</p></blockquote><p>在岛外，一个小丑错把利威尔当成了小孩，给他推销糖果，萨沙吃的很开心，艾伦遇见了一个在未来的记忆里会死于地鸣的小偷，并哭着和他道歉，而小偷小孩，带着调查兵团一群人来到了自己的家族，并用酒款待了他们，大家都喝的很开心，这是大家最后的，在一起的快乐记忆了，在那天晚上，艾伦问过三笠，“你是把我当作救你命的人，还是…家人?” 三笠红着脸回答了，家人。（三爷，不争气呀！）而在岛外，在清美的推荐下，艾伦等人也亲自参加了一个名叫“尤弥尔子民保护团体”举办的会议，但是这个会议的核心概要，仅仅是保护帕拉迪岛之外的艾尔迪亚人罢了，岛内的人依旧被他们称之为恶魔，还没听完，他就离开了会议厅。</p><h2 id="奇袭雷贝利欧"><a href="#奇袭雷贝利欧" class="headerlink" title="奇袭雷贝利欧"></a>奇袭雷贝利欧</h2><p>在854年的马莱，新的战士候补在活跃着，分别是柯特，法尔科兄弟，菲欧纳，伍德，贾碧，而马赛的弟弟，波波已经继承了颚之巨人。马莱和中东联合国已经打仗打了4年，最开始是吉克他们去岛上，马莱空虚，中东因此趁虚而入，后来因为超大型巨人不在了，再加上马莱过分依赖巨人，竟然有点颓势。中东的科技大概达到了一战的水平，目前飞机没有，又飞艇，火炮舰队，机关枪，机甲列车等等，其中中东的反巨人炮很厉害，可以当作是大号的雷枪，可以轻松击破莱纳的铠甲。在战壕中，马莱的马加特将军准备指挥艾尔迪亚人当炮灰，但是贾碧表示她想试试，她装作投降的小女孩，接近对方的碉堡，然后在对方的犹豫下，用手榴弹击毁了对面的装甲列车，颚之巨人和车力巨人趁机攻上高地。</p><blockquote><p>这里要说一个新人物，马加特，这个人是马莱战士们的上司，莱纳，贾碧等人都算是他的学生，而他也是马莱军队体系中的一个高官。</p></blockquote><p>另一边，吉克带着艾尔迪亚敢死队，就是吸了脊柱液烟雾的艾尔迪亚人，空降到了敌方的要塞上方，莱纳也跟着跳下，顺利拿下要塞，却被反巨人炮打了好几下。最后，在吉克团灭对方舰队的时候，莱纳为了救吉克，差点被对方舰队射过来的火炮给打死。马莱虽然获得了战争的胜利，但是，一个危险的信号展示了出来，人类的科技，已经快追上巨人了，巨人之力，不再是降维打击了。贾碧归来后，一下子成了小英雄，柯特也趁机各种捧贾碧，明眼人都看得出来，柯特不想让自己的弟弟因为继承巨人之力而短命。柯特自己要继承兽巨人的，而贾碧，是要继承她表哥莱纳的铠甲巨人的。</p><p>在战后的收容区，法尔科遇见了一个奇怪的人，这个人断了腿，眼睛还瞎了一个，这个人就是伪装潜入的艾伦。在战争过后，巨人小队在开会，结果依旧被监听，吉克表示现在的局势不容乐观，马莱被世界敌视，而要解决这种困境，就要重新编故事了，怎么编故事呢，就是像145王和战锤家族的勾当一样，先把帕拉迪岛的嘲讽拉满，让他们再次成为邪恶的代名词，他们再当英雄来拯救世界。拥有战锤巨人的戴巴家族已经在准备了，几天后就会开始演讲，到时候全世界的政要都会来的。在这里交代一下，戴巴等人是知道帕拉迪岛潜伏马莱这件事的，这次的演讲一方面是为了转移世界各个国家对马莱的仇恨到帕拉迪岛的头上，另一方面是引诱艾伦动手，造成帕拉迪岛和全世界为敌的局面，这是一个一石二鸟的狠毒计谋。历史是多么的相似啊，戴巴家族和一百年前一样，又要制造一个“英雄”，又想把仇恨转移到帕拉迪岛。在收容区，法尔科和艾伦聊天，艾伦用枭的姓氏来介绍自己，法尔科表示了自己不想让贾碧继承巨人等等。在地下室里，被罪恶感折磨了好几年的莱纳，正准备拿着猎枪自杀，但是听到了马尔科的自言自语，他停手了，他想起来了，自己还有责任。</p><p>第二天，艾伦和爷爷见面了，爷爷回想起了女儿和儿子的悲剧，非常的痛苦，差点一口气没上来，被医生带走了。在戴巴家族发表演讲的前，威利等人在做着准备，被清美女士带过来的调查兵团一群人也在做着准备，在演讲开始之前，皮克和波波被伊莲娜骗到了一个房间，困在了一起，另外一边，在法尔科的带领下，莱纳来到了演讲台后方的地下室，看到了割伤自己的手的艾伦。艾伦和莱纳几年不见，双方都变化很大，莱纳，这个曾经的老大哥跪着求艾伦杀了自己，艾伦却说能够理解莱纳，并让他坐下来，“莱纳，你坐啊。”威利·戴巴在艾伦的上方慷慨激昂的演讲着，他揭露了100年前的真相，原来100年前，并不是他们打败了145王，而是145王自己选择了和平，带着巨人和艾尔迪亚人去了帕拉迪岛，而如今，邪恶的艾伦夺取了始祖巨人，正在帕拉迪岛磨刀霍霍，我们不能再坐以待毙了！</p><blockquote><p>瞅瞅，什么叫国际演讲家啊，黑的都能说成白的，白的都能说成黑的，有话语权就是不一样啊，转手就能推翻145王的人设，就是为了给自己塑造英雄形象，好事都让他包圆了。</p></blockquote><p>随着他描述着艾伦多么的邪恶，帕拉迪岛多么的恐怖，表达了要对艾尔迪亚宣战之后，进击的巨人破土而出，并狠狠的撕碎了戴巴的身体。</p><blockquote><p>某个方面来说。戴巴家族成功了，因为戴巴家族从未使用巨人对别的国家发动过战争，所以在国际上还是有点人缘的，即便如此，大家对帕拉迪岛也只是观望态度，而威利·戴巴和各国政要因为进击的巨人的变身惨死，造成了各国彻底敌视帕拉迪岛，这是威利·戴巴用死换来的成果，但他绝对想不到，他这么做，害的战锤巨人丢失，害的世界被地鸣毁灭。</p></blockquote><p>在地下，无心战斗的莱纳勉强变身为巨人，为了保法尔科不死。在广场上，早有准备的马加特组织好了部队，向着艾伦开火，调查兵团也展开了行动，另外一边，被困住的皮克和波波也在同伴的帮助下来到了战场，戴巴家族的女仆，实际上是戴巴家族的妹妹，变身成了战锤巨人，和艾伦大战。在马莱的海港，阿尔敏变身超大型巨人，团灭了马莱海军，还有码头的房屋。尽管战锤很厉害，但还是被艾伦发现了他的弱点，原来这货是变身方式和别的巨人不同，战锤巨人是先把本体水晶化，然后从里面伸出一条线，用这个控制战锤巨人。艾伦连续三次变身，在消耗战中逼的战锤巨人体力耗尽，无法再战斗，前来支援的波波也被艾伦拆了胳膊和腿，还借用他的牙当胡桃夹子开启了水晶的防御，吞食了战锤巨人的血肉，吸收战锤巨人，当艾伦还想吃掉波波的时候，一边变身不彻底的莱纳摇摇晃晃的站了起来，体力不足的艾伦只好作罢，只好一拳打翻莱纳，溜之大吉。</p><p>在战场的另一边，影帝吉克再次被兵长秒杀，皮克被调查兵团炸碎了下半身，伍德，索菲纳阵亡，贾碧喜欢的门卫大叔被调查兵团所杀，愤怒的贾碧持枪要上调查兵团的逃生飞艇，法尔科留不住她，只能跟着她上去。调查兵团一行人成功的逃离，在飞艇上，他们正在庆祝任务圆满成功的时候，贾碧一个翻身，一枪打死了萨沙，萨沙临死之前，嘴里含糊的说着一个单词，也不知道是肉，还是尼克洛的名字。贾碧还想开枪，被法尔科阻止了，子弹贴着让的脑袋擦了过去。两个小孩被控制了起来，当贾碧被扭送到吉克面前的时候，她终于崩溃了，她没想到，那个荣誉马莱人心目中最高大上的战士长，竟然背叛了马莱。</p><p>在飞艇上，康尼悲痛欲绝，在余光中，他竟然看到艾伦在笑…</p><blockquote><p>其实是苦笑，窥视过未来的艾主席，也许早就知道了萨沙要牺牲，但是他无法改变未来。</p></blockquote><p>而艾伦，则被兵长再次的踢了一顿。</p><blockquote><p>转载<br>作者：差劲<br>链接：<a href="https://www.zhihu.com/question/58237145/answer/1650452896">https://www.zhihu.com/question/58237145/answer/1650452896</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;《进击的巨人》的全故事线&quot;&gt;&lt;a href=&quot;#《进击的巨人》的全故事线&quot; class=&quot;headerlink&quot; title=&quot;《进击的巨人》的全故事线&quot;&gt;&lt;/a&gt;《进击的巨人》的全故事线&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot;</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://www.nenufm.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="生活" scheme="https://www.nenufm.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="娱乐" scheme="https://www.nenufm.com/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>.NET运行时中的“Stack Walking”</title>
    <link href="https://www.nenufm.com/archives/b/"/>
    <id>https://www.nenufm.com/archives/b/</id>
    <published>2021-01-06T07:25:58.000Z</published>
    <updated>2021-01-07T06:01:02.704Z</updated>
    
    <content type="html"><![CDATA[<p>CLR大量使用了称为堆栈移动（或堆栈爬网）的技术。这涉及到迭代特定线程的调用帧序列，从最新的（线程的当前功能）向下回到栈的底部。</p><p>运行时将堆栈遍历用于多种目的：</p><ul><li>运行时在垃圾回收期间遍历所有线程的堆栈，查找托管根（在托管方法的框架中保存对象引用的局部变量，需要将这些引用报告给GC，以使对象保持活动状态，并可能在GC决定时跟踪其移动压缩堆）。</li><li>在某些平台上，堆栈处理程序用于异常处理（在第一遍中查找处理程序，在第二遍中展开堆栈）。</li><li>生成托管堆栈跟踪时，调试器将使用该功能。</li><li>各种其他方法（通常是那些与某些公共托管API接近的方法）执行堆栈遍历以获取有关其调用者的信息（例如该调用者的方法，类或程序集）。</li></ul><h2 id="CLR在哪里使用“Stack-Walking”？"><a href="#CLR在哪里使用“Stack-Walking”？" class="headerlink" title="CLR在哪里使用“Stack Walking”？"></a>CLR在哪里使用“Stack Walking”？</h2><p>在深入探讨“内部”之前，让我们看一下运行时在何处利用“堆栈遍历”，以下是完整列表（自.NET Core CLR’Release 2.2’起）。所有这些示例最终都在这里调用该Thread::StackWalkFrames(..)方法，并提供了一个callback在API遇到堆栈的新部分时触发的方法（有关更多信息，请参见下面的“如何使用它”）。</p><h4 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h4><ul><li>垃圾收集（GC）<ul><li>ScanStackRoots(..)</li></ul></li><li>异常处理（unwinding）<ul><li>x86-UnwindFrames(..)</li><li>x64-ResetThreadAbortState(..)</li></ul></li><li>异常处理（resumption）：<ul><li>ExceptionTracker::FindNonvolatileRegisterPointers(..) </li><li>ExceptionTracker::RareFindParentStackFrame(..)</li></ul></li><li>线程数：<ul><li>Thread::IsRunningIn(..)（AppDomain）</li><li>Thread::DetectHandleILStubsForDebugger(..) </li></ul></li><li>线程暂停：<ul><li>Thread::IsExecutingWithinCer()（“强制执行区域”）</li><li>Thread::HandledJITCase(..)</li></ul></li></ul><h4 id="调试-诊断"><a href="#调试-诊断" class="headerlink" title="调试/诊断"></a>调试/诊断</h4><ul><li><p>调试器</p><ul><li>DebuggerWalkStack(..)</li><li>DebuggerWalkStackProc() 从调用DebuggerWalkStack(..)</li></ul></li><li><p>托管API（例如 System.Diagnostics.StackTrace）</p><ul><li>经由托管代码的调用InternalCall（C＃）DebugStackTrace::GetStackFramesInternal(..)（C ++）</li><li>在DebugStackTrace::GetStackFramesHelper(..) 结束之前</li></ul></li><li><p>DAC（通过SOS） -扫描GC“根”</p><ul><li>DacStackReferenceWalker::WalkStack&lt;..&gt;(..)</li></ul></li><li><p>分析API</p><ul><li>ProfToEEInterfaceImpl::ProfilerStackWalkFramesWrapper(..)</li></ul></li><li><p>事件管道（诊断）</p><ul><li>EventPipe::WalkManagedStackForThread(..)</li></ul></li><li><p>CLR打印堆栈跟踪（到控制台/日志，仅DEBUG构建）</p><ul><li>PrintStackTrace()</li></ul></li></ul><h4 id="间接调用场景"><a href="#间接调用场景" class="headerlink" title="间接调用场景"></a>间接调用场景</h4><ul><li>反射<ul><li>RuntimeMethodHandle::GetCurrentMethod(..) 这里（回调）</li></ul></li><li>应用程序（App）域<ul><li>SystemDomain::GetCallersMethod(..)（GetCallersType(..)和GetCallersModule(..)）</li><li>SystemDomain::GetCallersModule(..) 这里（回调）</li></ul></li><li>“代码投放”<ul><li>CheckStacksAndPitch()</li></ul></li><li>可扩展类工厂（System.Runtime.InteropServices.ExtensibleClassFactory）<ul><li>RegisterObjectCreationCallback(..) </li></ul></li><li>堆栈采样器（未使用？）<ul><li>StackSampler::ThreadProc()</li></ul></li></ul><h2 id="堆栈抓取标记"><a href="#堆栈抓取标记" class="headerlink" title="堆栈抓取标记"></a>堆栈抓取标记</h2><p>上述情况之一值得仔细研究，但首先，为什么要使用coreclr / issues /＃21629（注释）中的“堆栈爬网标记” ：</p><blockquote><p>不幸的是，在netstandard2.0推送过程中添加了很多传统API，它们的行为取决于调用者。调用者基本上作为隐式参数传递给API。这些StackCrawlMark中的大多数都在那里支持这些API。</p></blockquote><p>因此，我们可以看到CLR本身内的多个功能需要了解其调用者。为了进一步了解这一点，让我们看一个例子GetType(string typeName)。这是从外部可见方法一直到完成工作的流程，请注意StackCrawlMark实例是如何传递的：</p><ul><li>Type::GetType(string typeName) （创建StackCrawlMark.LookForMyCaller）</li><li>RuntimeType::GetType(.., ref StackCrawlMark stackMark) </li><li>RuntimeType::GetTypeByName(.., ref StackCrawlMark stackMark, ..) </li><li>extern void GetTypeByName(.., ref StackCrawlMark stackMark, ..) 定义（调用本地代码，即[DllImport(JitHelpers.QCall, ..)]）</li><li>RuntimeTypeHandle::GetTypeByName(.., QCall::StackCrawlMarkHandle pStackMark, ..) </li><li>TypeHandle TypeName::GetTypeManaged(.., StackCrawlMark* pStackMark, ..) </li><li>TypeHandle TypeName::GetTypeWorker(.. , StackCrawlMark* pStackMark, ..) </li><li>SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark,..) </li><li>SystemDomain::GetCallersModule(StackCrawlMark* stackMark, ..) </li><li>SystemDomain::CallersMethodCallbackWithStackMark(..)</li></ul><p>另外，JIT（通过VM）还必须确保所有相关方法在调用堆栈中都可用，即它们不能被删除：</p><ul><li>防止内联CEEInfo::canInline(..)</li><li>防止通过“尾部呼叫”删除CEEInfo::canTailCall(..)</li></ul><p>但是，该StackCrawlMark功能目前正在清理中，因此将来可能会有所不同：</p><ul><li>从任务中删除NoInlining / StackCrawlMarks</li><li>从GetSatelliteAssembly删除堆栈标记</li><li>删除RtFieldInfo中不必要的StackCrawlMarks</li><li>避免在调用堆栈中不必要地传递堆栈爬网标记（如上所示示例！）</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>大多数.NET开发人员都会在处理异常时碰到“堆栈跟踪”。我原本打算在这里也描述“异常处理”，但是后来我打开了/src/vm/exceptionhandling.cpp，发现其中包含7,000行以上的代码！因此，我决定可以等待将来的帖子。</p><p>但是，如果您想了解有关“内部人员”的更多信息，我真的建议克里斯·布鲁姆（Chris Brumme）发表“异常模型（Exception Model）（2003）”，该主题是该主题的权威指南（另请参见他的Channel9视频），并且与往常一样，“ BotR”一章“每个（运行时）开发人员都需要了解的有关运行时异常的知识非常值得一读。</p><p>另外，我建议您看一下“内部异常”演讲中的幻灯片，以及相关的.NET Inside Out Part 2 —亚当·弗曼尼克（Adam Furmanek）编写的C＃中的异常处理和重新抛出。</p><h2 id="“堆栈漫游”-API"><a href="#“堆栈漫游”-API" class="headerlink" title="“堆栈漫游” API"></a>“堆栈漫游” API</h2><p>现在，我们已经看到了在那里它的使用，让我们来看看“栈行走” API本身。首先，如何使用？</p><h3 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h3><p>值得指出的是，从C＃/ F＃/ VB.NET代码访问它的唯一方法是通过StackTrace 类，只有运行时本身可以Thread::StackWalkFrames(..)直接调用。运行时中最简单的用法是EventPipe::WalkManagedStackForThread(..)（请参阅此处），如下所示。如您所见，在这种情况下ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS，指定相关标志很简单，然后提供回调，该回调在EventPipe类中是StackWalkCallback方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventPipe::WalkManagedStackForThread</span><span class="params">(Thread *pThread, StackContents &amp;stackContents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTRACTL</span><br><span class="line">    &#123;</span><br><span class="line">        NOTHROW;</span><br><span class="line">        GC_NOTRIGGER;</span><br><span class="line">        MODE_ANY;</span><br><span class="line">        PRECONDITION(pThread != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CONTRACTL_END;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Calling into StackWalkFrames in preemptive mode violates the host contract,</span></span><br><span class="line">    <span class="comment">// but this contract is not used on CoreCLR.</span></span><br><span class="line">    CONTRACT_VIOLATION( HostViolation );</span><br><span class="line">​</span><br><span class="line">    stackContents.Reset();</span><br><span class="line">​</span><br><span class="line">    StackWalkAction swaRet = pThread-&gt;StackWalkFrames(</span><br><span class="line">        (PSTACKWALKFRAMESCALLBACK) &amp;StackWalkCallback,</span><br><span class="line">        &amp;stackContents,</span><br><span class="line">        ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> ((swaRet == SWA_DONE) || (swaRet == SWA_CONTINUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StackWalkFrame(..)然后，该函数会在触发如下所示的回调之前进行实际遍历堆栈的繁重工作。在这种情况下，它仅记录“指令指针”（IP / CP）和“托管功能”，这是MethodDesc通过pCf-&gt;GetFunction()调用获得的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StackWalkAction <span class="title">EventPipe::StackWalkCallback</span><span class="params">(CrawlFrame *pCf, StackContents *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTRACTL</span><br><span class="line">    &#123;</span><br><span class="line">        NOTHROW;</span><br><span class="line">        GC_NOTRIGGER;</span><br><span class="line">        MODE_ANY;</span><br><span class="line">        PRECONDITION(pCf != <span class="literal">NULL</span>);</span><br><span class="line">        PRECONDITION(pData != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CONTRACTL_END;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Get the IP.</span></span><br><span class="line">    UINT_PTR controlPC = (UINT_PTR)pCf-&gt;GetRegisterSet()-&gt;ControlPC;</span><br><span class="line">    <span class="keyword">if</span> (controlPC == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pData-&gt;GetLength() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This happens for pinvoke stubs on the top of the stack.</span></span><br><span class="line">            <span class="keyword">return</span> SWA_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    _ASSERTE(controlPC != <span class="number">0</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Add the IP to the captured stack.</span></span><br><span class="line">    pData-&gt;Append(controlPC, pCf-&gt;GetFunction());</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Continue the stack walk.</span></span><br><span class="line">    <span class="keyword">return</span> SWA_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这个怎么运作"><a href="#这个怎么运作" class="headerlink" title="这个怎么运作"></a>这个怎么运作</h3><p>现在到最有趣的部分，如何运行时实际上遍历了堆栈。好吧，首先让我们从“ BotR”页面了解堆栈的外观：</p><p><img src="../../static/images/17af7fd01c668a3fffbdebf1713d5c065bc765dfcf431c70ee905c4835186046.png" alt="Stack Description from BotR"></p><p>要注意的主要事情是.NET“堆栈”可以包含3种类型的方法：</p><ul><li>托管-表示从C＃/ F＃/ VB.NET开始的代码，已转换为IL，然后最终由“ JIT编译器”编译为本机代码。</li><li>非托管-在运行时之外存在的完全本机代码，即运行时调用的OS函数或通过调用的用户函数P/Invoke。运行时只关心过渡到或超出常规的非托管代码，是不关心其中的堆栈帧。</li><li>运行时托管-仍是本机代码，但这有所不同，因为运行时案例更多关于此代码。例如，基本类库中有很多部分使用InternalCall方法，有关更多信息，请参见后面的“帮助器方法”框架部分。</li></ul><p>因此，“堆栈遍历”在进行过程中必须处理这些不同的情况。现在让我们看一下从入口点方法开始的“代码流” StackWalkFrames(..)：</p><ul><li>Thread::StackWalkFrames(..) 这里</li><li>入口点功能，通过这些标志可以控制“栈游走”的类型</li><li>Thread::StackWalkFramesEx(..) 这里</li><li>StackFrameIterator通过调用here设置的worker函数StackFrameIterator::Init(..)</li><li>StackFrameIterator::Next() 在这里，然后放手给初级工人的方法+</li><li>StackFrameIterator::NextRaw() 在这里，做5件事情：<ul><li>EEJitManager::JitCodeToMethodInfo(..) 在这里，它使用了一个看起来很酷的数据结构，称为“半字节映射”</li><li>NativeImageJitManager::JitCodeToMethodInfo(..)</li><li>ReadyToRunJitManager::JitCodeToMethodInfo(..)</li><li>x64-Thread::VirtualUnwindCallFrame(..) 在这里，然后VirtualUnwindNonLeafCallFrame(..) 在这里或VirtualUnwindLeafCallFrame(..) 这里打电话。所有这些函数都利用Windows API函数 RtlLookupFunctionEntry(..)进行实际的展开。</li><li>x86-::UnwindStackFrame(..) 在这里，依次UnwindEpilog(..) 在这里和UnwindEspFrame(..) 这里打电话。不同于x64，在x86所有CRL代码中，所有的“堆栈展开”都是手动完成的。<ul><li>CheckForSkippedFrames(..) 在这里，处理可能已在托管堆栈帧中分配的帧（例如，内联的p / invoke调用）。</li><li>UnwindStackFrame(..) 在这里，依次致电：</li><li>PostProcessingForManagedFrames(..) 在这里，确定堆栈遍历实际上是否在托管方法内，而不是在本机框架内。</li><li>ProcessIp(..) 这是根据当前指令指针（IP）查找当前托管方法（如果有）的工作。它通过调用到 这里，然后以以下其中一种方式结束： EECodeInfo::Init(..)</li><li>ProcessCurrentFrame(..) 在这里，做一些最后的整理和整理。</li></ul></li></ul></li><li>CrawlFrame::GotoNextFrame() 这里<ul><li>在pFrame-&gt;Next() 这里依次调用以遍历驱动“堆栈遍历”的框架的“链接列表”（稍后在这些“框架”中详细介绍）</li></ul></li><li>StackFrameIterator::Filter() 这里<ul><li>本质上，这是一个处理所有不同框架状态并决定是否应继续执行“堆栈遍历”的巨大switch声明。</li></ul></li></ul><p>时，它得到一个有效的帧它触发回调在Thread::MakeStackwalkerCallback(..) 这里和在经过一个指向当前CrawlFrame类这里定义，这暴露的方法，如IsFrameless()，GetFunction()和GetThisPointer()。该CrawlFrame实际上代表2分的情况，基于当前的IP：</p><ul><li>由此处定义的Frame类表示的本机代码，我们将在稍后讨论。</li><li>托管代码，从技术上讲就是“本地代码”的“托管代码”，因此更准确地说是托管堆栈框架。在这种情况下，将提供此处定义的MethodDesc类，您可以在相应的BotR章中阅读有关此关键CLR数据结构的更多信息。</li></ul><h3 id="看到它在行动"><a href="#看到它在行动" class="headerlink" title="看到它在行动"></a>看到它在行动</h3><p>幸运的是，我们能够在CLR（COMPLUS_LogEnable，COMPLUS_LogToFile＆COMPLUS_LogFacility）的调试版本中打开一些不错的诊断程序。有了适当的代码后，给出如下C＃代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodA();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodC();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodC</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stackTrace = <span class="keyword">new</span> StackTrace(fNeedFileInfo: <span class="literal">true</span>);</span><br><span class="line">        Console.WriteLine(stackTrace.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到如下所示的输出，您可以在其中看到“堆栈行走”过程。它开始于InitializeSourceInfo和CaptureStackTrace它们内部的方法StackTrace类（见这里），向上移动堆栈前MethodC- &gt; MethodB- &gt; MethodA，最后停止在Main函数。在实际展开之前，它会执行“ FILTER”和“ CONSIDER”步骤（“完成……结束”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TID 4740: STACKWALK    starting with partial context</span><br><span class="line">TID 4740: STACKWALK: [000] FILTER  : EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [001] CONSIDER: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [001] FILTER  : EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [002] CONSIDER: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cdd8  vtbl&#x3D; 00007ffd&#96;74995220 </span><br><span class="line">TID 4740: STACKWALK    LazyMachState::unwindLazyState(ip:00007FFD7439C45C,sp:000000029977C338)</span><br><span class="line">TID 4740: STACKWALK: [002] CALLBACK: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cdd8  vtbl&#x3D; 00007ffd&#96;74995220 </span><br><span class="line">TID 4740: STACKWALK    HelperMethodFrame::UpdateRegDisplay cached ip:00007FFD72FE9258, sp:000000029977D300</span><br><span class="line">TID 4740: STACKWALK: [003] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72fe9258  SP&#x3D; 00000002&#96;9977d300  method&#x3D;InitializeSourceInfo </span><br><span class="line">TID 4740: STACKWALK: [003] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72fe9258  SP&#x3D; 00000002&#96;9977d300  method&#x3D;InitializeSourceInfo </span><br><span class="line">TID 4740: STACKWALK: [004] about to unwind for &#39;InitializeSourceInfo&#39;, SP: 00000002&#96;9977d300 , IP: 00007ffd&#96;72fe9258 </span><br><span class="line">TID 4740: STACKWALK: [004] finished unwind for &#39;InitializeSourceInfo&#39;, SP: 00000002&#96;9977d480 , IP: 00007ffd&#96;72eeb671 </span><br><span class="line">TID 4740: STACKWALK: [004] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeb671  SP&#x3D; 00000002&#96;9977d480  method&#x3D;CaptureStackTrace </span><br><span class="line">TID 4740: STACKWALK: [004] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeb671  SP&#x3D; 00000002&#96;9977d480  method&#x3D;CaptureStackTrace </span><br><span class="line">TID 4740: STACKWALK: [005] about to unwind for &#39;CaptureStackTrace&#39;, SP: 00000002&#96;9977d480 , IP: 00007ffd&#96;72eeb671 </span><br><span class="line">TID 4740: STACKWALK: [005] finished unwind for &#39;CaptureStackTrace&#39;, SP: 00000002&#96;9977d5b0 , IP: 00007ffd&#96;72eeadd0 </span><br><span class="line">TID 4740: STACKWALK: [005] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeadd0  SP&#x3D; 00000002&#96;9977d5b0  method&#x3D;.ctor </span><br><span class="line">TID 4740: STACKWALK: [005] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeadd0  SP&#x3D; 00000002&#96;9977d5b0  method&#x3D;.ctor </span><br><span class="line">TID 4740: STACKWALK: [006] about to unwind for &#39;.ctor&#39;, SP: 00000002&#96;9977d5b0 , IP: 00007ffd&#96;72eeadd0 </span><br><span class="line">TID 4740: STACKWALK: [006] finished unwind for &#39;.ctor&#39;, SP: 00000002&#96;9977d5f0 , IP: 00007ffd&#96;14c620d3 </span><br><span class="line">TID 4740: STACKWALK: [006] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c620d3  SP&#x3D; 00000002&#96;9977d5f0  method&#x3D;MethodC </span><br><span class="line">TID 4740: STACKWALK: [006] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c620d3  SP&#x3D; 00000002&#96;9977d5f0  method&#x3D;MethodC </span><br><span class="line">TID 4740: STACKWALK: [007] about to unwind for &#39;MethodC&#39;, SP: 00000002&#96;9977d5f0 , IP: 00007ffd&#96;14c620d3 </span><br><span class="line">TID 4740: STACKWALK: [007] finished unwind for &#39;MethodC&#39;, SP: 00000002&#96;9977d630 , IP: 00007ffd&#96;14c62066 </span><br><span class="line">TID 4740: STACKWALK: [007] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62066  SP&#x3D; 00000002&#96;9977d630  method&#x3D;MethodB </span><br><span class="line">TID 4740: STACKWALK: [007] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62066  SP&#x3D; 00000002&#96;9977d630  method&#x3D;MethodB </span><br><span class="line">TID 4740: STACKWALK: [008] about to unwind for &#39;MethodB&#39;, SP: 00000002&#96;9977d630 , IP: 00007ffd&#96;14c62066 </span><br><span class="line">TID 4740: STACKWALK: [008] finished unwind for &#39;MethodB&#39;, SP: 00000002&#96;9977d660 , IP: 00007ffd&#96;14c62016 </span><br><span class="line">TID 4740: STACKWALK: [008] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62016  SP&#x3D; 00000002&#96;9977d660  method&#x3D;MethodA </span><br><span class="line">TID 4740: STACKWALK: [008] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62016  SP&#x3D; 00000002&#96;9977d660  method&#x3D;MethodA </span><br><span class="line">TID 4740: STACKWALK: [009] about to unwind for &#39;MethodA&#39;, SP: 00000002&#96;9977d660 , IP: 00007ffd&#96;14c62016 </span><br><span class="line">TID 4740: STACKWALK: [009] finished unwind for &#39;MethodA&#39;, SP: 00000002&#96;9977d690 , IP: 00007ffd&#96;14c61f65 </span><br><span class="line">TID 4740: STACKWALK: [009] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c61f65  SP&#x3D; 00000002&#96;9977d690  method&#x3D;Main </span><br><span class="line">TID 4740: STACKWALK: [009] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c61f65  SP&#x3D; 00000002&#96;9977d690  method&#x3D;Main </span><br><span class="line">TID 4740: STACKWALK: [00a] about to unwind for &#39;Main&#39;, SP: 00000002&#96;9977d690 , IP: 00007ffd&#96;14c61f65 </span><br><span class="line">TID 4740: STACKWALK: [00a] finished unwind for &#39;Main&#39;, SP: 00000002&#96;9977d6d0 , IP: 00007ffd&#96;742f9073 </span><br><span class="line">TID 4740: STACKWALK: [00a] FILTER  : NATIVE   : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0 </span><br><span class="line">TID 4740: STACKWALK: [00b] CONSIDER: EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977de58  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00b] FILTER  : EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977de58  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00c] CONSIDER: EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977e7e0  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00c] FILTER  : EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977e7e0  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: SWA_DONE: reached the end of the stack</span><br></pre></td></tr></table></figure><p>要了解更多信息，可以在\vm\stackwalk.cpp中搜索这些诊断消息，例如在Thread::DebugLogStackWalkInfo(..) 此处</p><h2 id="展开“本地”代码"><a href="#展开“本地”代码" class="headerlink" title="展开“本地”代码"></a>展开“本地”代码</h2><p>如这篇出色的文章所述：</p><blockquote><p>从根本上讲，有两种主要方法可以在ABI（应用程序二进制接口）中实现异常传播：</p><ul><li>“动态注册”，在每个激活记录中带有框架指针，并组织为一个链表。这使得堆栈快速展开，但以必须在调用其他函数的每个函数中设置帧指针为代价。这也更容易实现。</li><li>“表驱动”，其中编译器和汇编器在程序代码旁边创建数据结构，以指示哪些代码地址对应于哪些激活记录大小。在例如GNU工具链中，这称为“呼叫帧信息”（CFI）数据。生成异常时，将加载此表中的数据以确定如何展开。这使得异常传播较慢，但一般情况下较快。</li></ul></blockquote><p>事实证明，.NET使用“表驱动”方法，原因在“ BotR”中进行了解释：</p><blockquote><p>框架的确切定义因平台而异，并且在许多平台上，并没有硬性定义所有功能都遵循的框架格式（x86就是一个示例）。相反，编译器通常可以自由地优化帧的确切格式。在此类系统上，无法保证stackwalk将返回100％正确或完整的结果（出于调试目的，使用诸如pdbs之类的调试符号来填补空白，以便调试器可以生成更准确的堆栈跟踪）。</p></blockquote><blockquote><p>对于CLR，这不是问题，因为我们不需要完全通用的堆栈遍历。取而代之的是，我们只对那些受管理的框架（即代表托管方法）感兴趣，或者在某种程度上，这些框架来自用于实现部分运行时本身的非托管代码。特别是，除了说明此类帧在何处过渡到运行时本身或从运行时本身过渡（即我们关心的帧类型之一）的位置外，不能保证第三方非托管帧的保真度。</p></blockquote><h2 id="镜框"><a href="#镜框" class="headerlink" title="镜框"></a>镜框</h2><p>为了启用本机代码的“展开”或更严格地实现本机代码的“进入”和“退出”转换，CLR使用的机制Frames，该机制在此处的源代码中定义。这些框架排列成层次结构Frame，每种情况都有一种类型，有关这些个体的更多信息，Frames请在此处查看出色的源代码注释。</p><ul><li>框架（抽象/基类）<ul><li>ComMethodFrame</li><li>UMThkCallFrame</li><li>ComPrestubMethodFrame</li><li>StubHelperFrame</li><li>SecureDelegateFrame</li><li>FramedMethodFrame</li><li>组播帧</li><li>ComPlusMethodFrame</li><li>PInvokeCalliFrame</li><li>PrestubMethodFrame</li><li>StubDispatchFrame</li><li>外部方法框架</li><li>TPMethodFrame</li><li>HelperMethodFrame_1OBJ</li><li>HelperMethodFrame_2OBJ</li><li>HelperMethodFrame_3OBJ</li><li>HelperMethodFrame_PROTECTOBJ</li><li>RedirectedThreadFrame</li><li>GC框架</li><li>FaultingExceptionFrame</li><li>HijackFrame</li><li>可恢复帧</li><li>InlinedCallFrame</li><li>HelperMethodFrame</li><li>TransitionFrame</li><li>UnmanagedToManagedFrame</li><li>ContextTransitionFrame</li><li>尾叫帧</li><li>ProtectByRefsFrame</li><li>ProtectValueClassFrame</li><li>调试器类InitMarkFrame</li><li>DebuggerSecurityCodeMarkFrame</li><li>调试器退出框架</li><li>调试器U2MCatchHandlerFrame</li><li>FuncEvalFrame</li><li>ExceptionFilterFrame</li></ul></li></ul><h2 id="“帮助方法”框架"><a href="#“帮助方法”框架" class="headerlink" title="“帮助方法”框架"></a>“帮助方法”框架</h2><p>但是，为了理解这一点，让我们看一种Frame称为的HelperMethodFrame（上）。当运行时的.NET代码调用C ++代码进行繁重的操作时（通常出于性能原因），将使用此功能。一个示例是，如果您Environment.GetCommandLineArgs()最终以该代码（C＃）进行调用，但请注意，它最终会调用extern标记为的方法InternalCall：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">string</span>[] <span class="title">GetCommandLineArgsNative</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>这意味着，该方法的其余部分在C ++运行时实现，你可以看到方法调用是如何有线了，结束了之前SystemNative::GetCommandLineArgs 在这里其如下所示，：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FCIMPL0(Object*, SystemNative::GetCommandLineArgs)</span><br><span class="line">&#123;</span><br><span class="line">    FCALL_CONTRACT;</span><br><span class="line"></span><br><span class="line">    PTRARRAYREF strArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    HELPER_METHOD_FRAME_BEGIN_RET_1(strArray); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; started here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error handling and setup code removed for clarity</span></span><br><span class="line"></span><br><span class="line">    strArray = (PTRARRAYREF) AllocateObjectArray(numArgs, g_pStringClass);</span><br><span class="line">    <span class="comment">// Copy each argument into new Strings.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numArgs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        STRINGREF str = StringObject::NewString(argv[i]);</span><br><span class="line">        STRINGREF * destData = ((STRINGREF*)(strArray-&gt;GetDataPtr())) + i;</span><br><span class="line">        SetObjectReference((OBJECTREF*)destData, (OBJECTREF)str, strArray-&gt;GetAppDomain());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] argv;</span><br><span class="line"></span><br><span class="line">    HELPER_METHOD_FRAME_END(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; ended/closed here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OBJECTREFToObject(strArray);</span><br><span class="line">&#125;</span><br><span class="line">FCIMPLEND</span><br></pre></td></tr></table></figure><p>注意：此代码大量使用了宏，有关原始代码和扩展版本（发布和调试），请参见本要点。此外，如果您想了解有关这些神秘物品FCalls（以及相关的物品QCalls）的更多信息，请参见Mscorlib和“ BotR”中的“调用运行时”。</p><p>但是在代码示例中要看的主要是HELPER_METHOD_FRAME_BEGIN_RET_1()宏，最终安装了HelperMethodFrame_1OBJ类的实例。宏扩展为如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FrameWithCookie &lt; HelperMethodFrame_1OBJ &gt; __helperframe(__me, Frame::FRAME_ATTR_NONE, (OBJECTREF * ) &amp; strArray); </span><br><span class="line">&#123;</span><br><span class="line">  __helperframe.Push(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; pushed</span></span><br><span class="line"></span><br><span class="line">  Thread * CURRENT_THREAD = __helperframe.GetThread();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> CURRENT_THREAD_AVAILABLE = <span class="literal">true</span>;</span><br><span class="line">  (<span class="keyword">void</span>) CURRENT_THREAD_AVAILABLE;; &#123;</span><br><span class="line">Exception * __pUnCException = <span class="number">0</span>;</span><br><span class="line">Frame * __pUnCEntryFrame = ( &amp; __helperframe);</span><br><span class="line"><span class="keyword">bool</span> __fExceptionCatched = <span class="literal">false</span>;;</span><br><span class="line"><span class="keyword">try</span> &#123;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Original code from SystemNative::GetCommandLineArgs goes in here</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception * __pException) &#123;;</span><br><span class="line">  <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">  __pUnCException = __pException;</span><br><span class="line">  UnwindAndContinueRethrowHelperInsideCatch(__pUnCEntryFrame, __pUnCException);</span><br><span class="line">  __fExceptionCatched = <span class="literal">true</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__fExceptionCatched) &#123;;</span><br><span class="line">  UnwindAndContinueRethrowHelperAfterCatch(__pUnCEntryFrame, __pUnCException);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __helperframe.Pop(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; popped</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：Push()和Pop()相对_helperMethodFrame应，可用于“堆栈行走”。您还可以看到CLR放置的try/catch块，以确保将本机代码中的任何异常转换为C＃/ F＃/ VB.NET代码可以处理的托管异常。如果您有兴趣，可以在此摘要中找到完整的宏扩展。</p><p>因此，总而言之，当调用本机代码时，它们Frames会被推送到“链接列表”上，而从本机代码返回时，它们会从列表中弹出。这意味着“链接列表”随时都包含所有当前或活动列表Frames。</p><h2 id="本机放松信息"><a href="#本机放松信息" class="headerlink" title="本机放松信息"></a>本机放松信息</h2><p>除了创建“框架”之外，CLR还确保C ++编译器为本地代码发出“展开信息”。如果我们使用DUMPBIN工具并运行，我们可以看到这一点dumpbin /UNWINDINFO coreclr.dll。我们得到以下输出SystemNative::GetCommandLineArgs(..)（之前已经看过）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0002F064 003789B0 00378B7E 004ED1D8  ?GetCommandLineArgs@SystemNative@@SAPEAVObject@@XZ (public: static class Object * __cdecl SystemNative::GetCommandLineArgs(void))</span><br><span class="line">  Unwind version: 1</span><br><span class="line">  Unwind flags: EHANDLER UHANDLER</span><br><span class="line">  Size of prologue: 0x3B</span><br><span class="line">  Count of codes: 13</span><br><span class="line">  Unwind codes:</span><br><span class="line">    29: SAVE_NONVOL, register&#x3D;r12 offset&#x3D;0x1C8</span><br><span class="line">    25: SAVE_NONVOL, register&#x3D;rdi offset&#x3D;0x1C0</span><br><span class="line">    21: SAVE_NONVOL, register&#x3D;rsi offset&#x3D;0x1B8</span><br><span class="line">    1D: SAVE_NONVOL, register&#x3D;rbx offset&#x3D;0x1B0</span><br><span class="line">    10: ALLOC_LARGE, size&#x3D;0x190</span><br><span class="line">    09: PUSH_NONVOL, register&#x3D;r15</span><br><span class="line">    07: PUSH_NONVOL, register&#x3D;r14</span><br><span class="line">    05: PUSH_NONVOL, register&#x3D;r13</span><br><span class="line">  Handler: 00148F14 __GSHandlerCheck_EH</span><br><span class="line">  EH Handler Data: 00415990</span><br><span class="line">  GS Unwind flags: EHandler UHandler</span><br><span class="line">  Cookie Offset: 00000180</span><br><span class="line"></span><br><span class="line">0002F070 00378B7E 00378BB4 004ED26C</span><br><span class="line">  Unwind version: 1</span><br><span class="line">  Unwind flags: EHANDLER UHANDLER</span><br><span class="line">  Size of prologue: 0x0A</span><br><span class="line">  Count of codes: 2</span><br><span class="line">  Unwind codes:</span><br><span class="line">    0A: ALLOC_SMALL, size&#x3D;0x20</span><br><span class="line">    06: PUSH_NONVOL, register&#x3D;rbp</span><br><span class="line">  Handler: 0014978C __CxxFrameHandler3</span><br><span class="line">  EH Handler Data: 00415990</span><br></pre></td></tr></table></figure><p>如果您想了解此处的更多信息，我真的建议您阅读出色的文章x64手动堆栈重建和堆栈遍历。但实质上，“展开信息”描述了方法中使用的寄存器以及该方法的堆栈数。这些信息足以告诉运行时如何在堆栈中“展开”该特定方法。</p><h2 id="Windows和Unix之间的差异"><a href="#Windows和Unix之间的差异" class="headerlink" title="Windows和Unix之间的差异"></a>Windows和Unix之间的差异</h2><p>但是，更复杂的是，“本机代码展开”对“ Windows”和“ Unix”使用了不同的机制，如coreclr / issues /＃177（注释）所述：</p><blockquote><ul><li>用于管理代码的堆栈遍历器。JIT将生成常规的Windows样式展开信息。我们将重用当前已检入的Windows展开器代码中的调试器组件，以展开Linux / Mac上托管代码中的调用。不幸的是，这项工作需要对运行时进行更改，而这些更改目前无法在CoreCLR存储库中进行测试，因此现在很难在公开场合进行。但是我们正在努力解决这一问题，因为正如我在开始时提到的那样，我们的目标是在公众中开展大多数工作。</li><li>适用于本机代码的Stack Walker。在这里，除了其他所有内容外，我们还需要允许GC释放当前进程中任何线程的本机堆栈，直到找到托管帧为止。当前，我们正在考虑使用libunwind（<a href="http://www.nongnu.org/libunwind%EF%BC%89%E9%87%8A%E6%94%BE%E6%9C%AC%E6%9C%BA%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E3%80%82@janvorli%E5%81%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C%EF%BC%8C%E4%BC%BC%E4%B9%8E%E5%8F%AF%E4%BB%A5%E6%BB%A1%E8%B6%B3%E6%88%91%E4%BB%AC%E7%9A%84%E9%9C%80%E6%B1%82%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E6%9C%89%E4%BD%BF%E7%94%A8%E6%AD%A4%E5%BA%93%E7%9A%84%E4%BB%BB%E4%BD%95%E7%BB%8F%E9%AA%8C%E6%88%96%E6%9C%89%E4%BB%BB%E4%BD%95%E6%84%8F%E8%A7%81/%E5%BB%BA%E8%AE%AE%EF%BC%8C%E8%AF%B7%E5%91%8A%E8%AF%89%E6%88%91%E4%BB%AC%E3%80%82">http://www.nongnu.org/libunwind）释放本机调用堆栈。@janvorli做过一些原型设计/实验，似乎可以满足我们的需求。如果您有使用此库的任何经验或有任何意见/建议，请告诉我们。</a></li></ul></blockquote><p>这还表明，对于“托管”或“本机”代码有两种不同的“展开”机制，我们将讨论“展开“ JITted”代码中的“用于托管代码的堆栈行进器”如何工作。</p><p>在coreclr / issues /＃177（注释）中也有更多信息：</p><blockquote><p>我的当前工作分为两部分，正如@ sergiy-k已经提到的那样。在windows风格开卷将被用于实时编译的代码和Unix的开卷本地代码使用的libunwind的低级别unw_xxxx的功能，如unw_step等。</p></blockquote><p>因此，对于“本机代码”，运行时使用特定于操作系统的机制，即在Unix上使用开源的“ libunwind”库。您可以在下面的代码（从这里开始）中看到不同之处，在Windows Thread::VirtualUnwindCallFrame(..)（实现）下被调用，但是在Unix（即FEATURE_PAL）PAL_VirtualUnwind(..)（实现）上被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FEATURE_PAL</span></span><br><span class="line">    pvControlPc = Thread::VirtualUnwindCallFrame(&amp;ctx, &amp;nonVolRegPtrs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// !FEATURE_PAL</span></span></span><br><span class="line">    ...</span><br><span class="line">    BOOL success = PAL_VirtualUnwind(&amp;ctx, &amp;nonVolRegPtrs);</span><br><span class="line">    ...</span><br><span class="line">    pvControlPc = GetIP(&amp;ctx);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !FEATURE_PAL</span></span></span><br></pre></td></tr></table></figure><p>在进一步介绍之前，这里有一些指向.NET Core CLR移植到Linux时为支持“堆栈移动”所做的工作的链接：</p><ul><li>[x86 / Linux]支持简单异常捕获</li><li>[ARM / Linux] coreclr因libunwind＃6698中缺少DWARF功能而失败</li><li>修改Windows amd64展开器，使其在Uni…上作为固定代码展开器工作＃259</li><li>重构libunwind以在OSX上工作＃284</li><li>重新实现PAL＃308的本机异常处理</li><li>将Windows展开器代码移出debug文件夹。</li><li>.NET核心依赖项（包括“ libunwind”）</li><li>sos“ ClrStack”命令现在可以使用</li></ul><h2 id="展开“-JITted”代码"><a href="#展开“-JITted”代码" class="headerlink" title="展开“ JITted”代码"></a>展开“ JITted”代码</h2><p>最后，我们将研究“托管代码”的情况，即以C＃/ F＃/ VB.NET开始的代码被转换为IL，然后由“ JIT编译器”编译为本地代码。这是您通常希望在“堆栈跟踪”中看到的代码，因为它是您自己编写的代码！</p><h3 id="来自“-JIT编译器”的帮助"><a href="#来自“-JIT编译器”的帮助" class="headerlink" title="来自“ JIT编译器”的帮助"></a>来自“ JIT编译器”的帮助</h3><p>简而言之，发生的事情是，当代码被“ JITted”时，编译器还会发出一些额外的信息，这些信息通过在此处EECodeInfo定义的类存储。另见“开卷信息”部分中的JIT编译器&lt; - &gt;运行界面，注意它是如何拥有单独的章节，，和。TARGET_ARMTARGET_ARM64TARGET_X86TARGET_UNIX</p><p>另外，CodeGen::genFnProlog() 这里的JIT发出一个函数“序言”，其中包含一些与“展开”相关的数据。这也imlemented在CEEJitInfo::allocUnwindInfo(..)在这一段代码，其表现不同对每个CPU架构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_TARGET_X86_)</span></span><br><span class="line">    <span class="comment">// Do NOTHING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_AMD64_)</span></span><br><span class="line">    pUnwindInfo-&gt;Flags = UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER;</span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)ALIGN_UP(&amp;(pUnwindInfo-&gt;UnwindCode[pUnwindInfo-&gt;CountOfUnwindCodes]), <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_ARM64_)</span></span><br><span class="line">    *(LONG *)pUnwindInfo |= (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); <span class="comment">// X bit</span></span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, <span class="keyword">sizeof</span>(ULONG)));</span><br><span class="line">    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_ARM_)</span></span><br><span class="line">    *(LONG *)pUnwindInfo |= (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); <span class="comment">// X bit</span></span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, <span class="keyword">sizeof</span>(ULONG)));</span><br><span class="line">    *pPersonalityRoutine = (TADDR)ProcessCLRException - baseAddress;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而且，JIT有几种Compiler::unwindXXX(..)方法，所有方法都在每个CPU的源文件中实现：</p><ul><li>/src/jit/unwind.cpp</li><li>/src/jit/unwind arm .cpp</li><li>/src/jit/unwind x86 .cpp</li><li>/src/jit/unwind amd64 .cpp</li><li>/src/jit/unwind arm64 .cpp</li></ul><p>幸运的是，我们可以要求JIT输出它发出的展开信息，但这仅适用于CLR的调试版本。给定一个像这样的简单方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodB();</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        Console.WriteLine(ex.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用SET COMPlus_JitUnwindDump=MethodA，我们将获得以下输出，其中包含2个“ Unwind Info”部分，一个用于try，另一个用于该catch块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Unwind Info:</span><br><span class="line">  &gt;&gt; Start offset   : 0x000000 (not in unwind data)</span><br><span class="line">  &gt;&gt;   End offset   : 0x00004e (not in unwind data)</span><br><span class="line">  Version           : 1</span><br><span class="line">  Flags             : 0x00</span><br><span class="line">  SizeOfProlog      : 0x07</span><br><span class="line">  CountOfUnwindCodes: 4</span><br><span class="line">  FrameRegister     : none (0)</span><br><span class="line">  FrameOffset       : N&#x2F;A (no FrameRegister) (Value&#x3D;0)</span><br><span class="line">  UnwindCodes       :</span><br><span class="line">    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 11 * 8 + 8 &#x3D; 96 &#x3D; 0x60</span><br><span class="line">    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)</span><br><span class="line">    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)</span><br><span class="line">    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)</span><br><span class="line">Unwind Info:</span><br><span class="line">  &gt;&gt; Start offset   : 0x00004e (not in unwind data)</span><br><span class="line">  &gt;&gt;   End offset   : 0x0000e2 (not in unwind data)</span><br><span class="line">  Version           : 1</span><br><span class="line">  Flags             : 0x00</span><br><span class="line">  SizeOfProlog      : 0x07</span><br><span class="line">  CountOfUnwindCodes: 4</span><br><span class="line">  FrameRegister     : none (0)</span><br><span class="line">  FrameOffset       : N&#x2F;A (no FrameRegister) (Value&#x3D;0)</span><br><span class="line">  UnwindCodes       :</span><br><span class="line">    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 &#x3D; 48 &#x3D; 0x30</span><br><span class="line">    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)</span><br><span class="line">    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)</span><br><span class="line">    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)</span><br></pre></td></tr></table></figure><p>然后，按照上面的“如何工作”部分中的说明，在“堆栈遍历”期间查找此“展开信息” 。</p><p>因此，下次您遇到“堆栈跟踪”时，请记住，要使之成为可能的工作量很大！！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;CLR大量使用了称为堆栈移动（或堆栈爬网）的技术。这涉及到迭代特定线程的调用帧序列，从最新的（线程的当前功能）向下回到栈的底部。&lt;/p&gt;
&lt;p&gt;运行时将堆栈遍历用于多种目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时在垃圾回收期间遍历所有线程的堆栈，查找托管根（在托管方法的框架中保</summary>
        
      
    
    
    
    <category term="编程" scheme="https://www.nenufm.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term=".Net" scheme="https://www.nenufm.com/tags/Net/"/>
    
    <category term="程序性能" scheme="https://www.nenufm.com/tags/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    
    <category term=".Net源码" scheme="https://www.nenufm.com/tags/Net%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>使用Flamegraph分析.NET启动时间</title>
    <link href="https://www.nenufm.com/archives/a/"/>
    <id>https://www.nenufm.com/archives/a/</id>
    <published>2021-01-06T07:07:05.000Z</published>
    <updated>2021-01-07T06:01:08.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NET运行时在启动过程中在哪里花费时间？"><a href="#NET运行时在启动过程中在哪里花费时间？" class="headerlink" title=".NET运行时在启动过程中在哪里花费时间？"></a>.NET运行时在启动过程中在哪里花费时间？</h1><blockquote><p>翻译自 <a href="https://mattwarren.org/2020/03/03/Analysing-.NET-Runtime-Startup-with-Flamegraphs/">https://mattwarren.org/2020/03/03/Analysing-.NET-Runtime-Startup-with-Flamegraphs/</a></p></blockquote><h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><p>在本练习中，我们仅关注程序启动期间的.NET运行时，我们确保正在运行最少数量的用户代码，因此使用以下“Hello World”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Hello World!&quot;);</span><br><span class="line">            Console.WriteLine(&quot;Press &lt;ENTER&gt; to exit&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以添加Console.ReadLine()调用是因为我想确保在PerfView仍在收集数据的同时该过程不会退出。</p><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>PerfView是一个非常强大的程序，但不是最用户友好的工具，因此我整理了逐步指南：</p><ul><li>下载并运行最新版本的“ PerfView.exe”</li><li>单击“Run a command”或（Alt-R），然后单击“collect data while the command is running”</li><li>确保输入以下值：<ul><li>“Command”</li><li>“Current Dir”</li></ul></li><li>如果尚未选中，请勾选“ Cpu Samples ”</li><li>将“ Max Collect Sec ”设置为15秒（因为我们的“ HelloWorld”应用程序永远不会退出，因此我们需要确保PerfView在某个时刻停止收集数据）</li><li>确保已选择“ .NET Symbol Collection ”</li><li>点击运行命令</li></ul><p><img src="../../static/images/c5ff606a305ee5a5d7cef2a98cc97ee7fe1959cb6ac5e7b77087f6f05868ddbc.png" alt="PerfView - Collection Options - annotated"></p><p>如果随后查看该日志，则可以看到该日志正在收集数据，获取符号并最终将所有内容写到.zip文件中。完成该过程后，您应该在主UI的左侧窗格中看到新创建的文件，在这种情况下，该文件称为“ PerfViewData.etl.zip”</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>拥有“ .etl.zip”文件后，双击该文件，您将看到带有所有可用数据的树状视图。现在，选择“ CPU Stacks”，将显示如下视图：</p><p><img src="../../static/images/8ea3f490fbb7e3c8da7f097acdd3dcc46e14ffb6f85eacf16c077e1ee0d0ca97.png" alt="PerfView - Unresolved Symbols"></p><p>注意列表中有很多“？” 的字符，这意味着PerfView无法解决方法名称，因为它尚未解析运行时dll的必要符号。让我们修复：</p><ul><li>打开“ CPU堆栈”</li><li>在列表中，选择“ HelloWorld ”过程（PerfView在整个计算机范围内收集数据）</li><li>在“ GroupPats ”下拉列表中，选择“ [no grouping]”</li><li>可选，将“符号路径”从默认值更改为其他值</li><li>在“按名称”标签中，按“ Ctrl + A”以选择所有行</li><li>右键单击并选择“查找符号”（或仅单击“ Alt + S”）</li></ul><p>现在，”CPU Stacks”视图应如下所示：</p><p><img src="../../static/images/a72b381b15a76ee06490bfe124cdc823ac035f8c461b2c1f2c840e21cfd3a5b8.png" alt="PerfView - Resolved Symbols"></p><p>最后，我们可以获得所需的数据：</p><ul><li>选择“Flame Graph”标签</li><li>将“ GroupPats ”更改为以下值之一以获得更好的火焰图：</li><li>将“ Fold％ ”更改为更高的数字，可能是3％，以消除一些悠长的线条（更高的条形，但将丢失一些细节信息）</li></ul><p><img src="../../static/images/818230a3c2095bc6be930df1506d17a211bf243b09562c9df905d46ae0475162.png" alt="PerfView - Flamegraph"></p><p>现在，在这一点上，我建议用PerfView数据导出为可装入一个格式<a href="https://speedscope.app/">https://speedscope.app</a> 这个网站上可以生成更直观的火焰图。为此，单击File-&gt;Save View As，然后在“Save as type”框中选择“Speed Scope Format”。之后即可上传到speedscope.app 进行分析。</p><h2 id="NET运行时启动的分析"><a href="#NET运行时启动的分析" class="headerlink" title=".NET运行时启动的分析"></a>.NET运行时启动的分析</h2><p>最后，我们可以回答我们原来的问题：</p><blockquote><p>.NET运行时在启动过程中在哪里花费时间？</p></blockquote><p>这是来自Flamegraph的数据，摘要为文本，并链接了.NET Core Runtime源代码中的相应功能：</p><ul><li>整个应用-100％ -233.28ms</li><li>一切，除了helloworld!wmain- 21％</li><li>helloworld!wmain- 79％ - 184.57ms<ul><li>coreclr!RunMain- 9.9％， - 23.12ms</li><li>coreclr!RunStartupHooks- 8.1％， - 19.00ms</li><li>coreclr!CorHost2::Start- 9％， - 20.98ms</li><li>coreclr!CorHost2::CreateAppDomain- 10％ - 23.52ms</li><li>hostpolicy!create_hostpolicy_context- 30％ - 70.92ms</li><li>hostpolicy!create_coreclr- 22％ - 50.51ms</li><li>hostpolicy!runapp- 20％ - 46.20ms 最终调用到Assembly::ExecuteMainMethod </li><li>hostfxr!resolve_frameworks_for_app- 3.4％， - 7.89ms</li></ul></li></ul><p>因此，运行时花费时间的主要位置是：</p><ul><li>花了总时间的30％来启动运行时，这是通过“host policy”控制的，这主要发生在hostpolicy!create_hostpolicy_context总时间的30％中</li><li>22％的时间花费在运行时本身及其创建的初始（唯一）AppDomain的初始化上，这可以在CorHost2::Start（native）和CorHost2::CreateAppDomain（managed）中看到。</li><li>从上面开始，在我们的“ Hello World”代码示例中使用了20％的JITting并执行了该Main方法Assembly::ExecuteMainMethod。</li></ul><p>为了确认最后一点，我们可以返回PerfView并查看它产生的“ JIT统计摘要”。从主菜单的“高级组”-&gt;“ JIT统计信息”下，我们看到JITing花费了23.1 ms或9.1％的CPU总时间：</p><p><img src="../../static/images/8fb1101eca336ff59b7bf83ae254136420c5850270f954022f75aeed0004a2ec.png" alt="PerfView - JIT Stats for HelloWorld"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;NET运行时在启动过程中在哪里花费时间？&quot;&gt;&lt;a href=&quot;#NET运行时在启动过程中在哪里花费时间？&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="编程" scheme="https://www.nenufm.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term=".Net" scheme="https://www.nenufm.com/tags/Net/"/>
    
    <category term="程序性能" scheme="https://www.nenufm.com/tags/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    
    <category term="PerfView" scheme="https://www.nenufm.com/tags/PerfView/"/>
    
    <category term="火焰图" scheme="https://www.nenufm.com/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    
  </entry>
  
</feed>
