<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="留声与视">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://nenufm.com">
    <!--SEO-->

<meta name="keywords" content=".Net,程序性能,.Net源码" />


<meta name="description" content="CLR大量使用了称为堆栈移动（或堆栈爬网）的技术。这涉及到迭代特定线程的调用帧序列，从最新的（线程的当前功能）向下回到栈的底部。
运行时将堆栈遍历用于多种目的：

运行时在垃圾回收期间遍历所有线..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    .NET运行时中的“Stack Walking” |
    
    留声与视
</title>

<link rel="alternate" href="/atom.xml" title="留声与视" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header" >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='dorthl'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://nenufm.com">
                        留声与视</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa fa-list-ul"></i>
                                时间轴</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/about/"><i class="fa fa-ravelry"></i>
                                关于</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id=".NET运行时中的“Stack Walking”">
            
            .NET运行时中的“Stack Walking”
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/Net/" rel="tag">.Net</a> <a class="tag-none-link" href="/tags/Net%E6%BA%90%E7%A0%81/" rel="tag">.Net源码</a> <a class="tag-none-link" href="/tags/%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" rel="tag">程序性能</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2021/01/06</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>CLR大量使用了称为堆栈移动（或堆栈爬网）的技术。这涉及到迭代特定线程的调用帧序列，从最新的（线程的当前功能）向下回到栈的底部。</p>
<p>运行时将堆栈遍历用于多种目的：</p>
<ul>
<li>运行时在垃圾回收期间遍历所有线程的堆栈，查找托管根（在托管方法的框架中保存对象引用的局部变量，需要将这些引用报告给GC，以使对象保持活动状态，并可能在GC决定时跟踪其移动压缩堆）。</li>
<li>在某些平台上，堆栈处理程序用于异常处理（在第一遍中查找处理程序，在第二遍中展开堆栈）。</li>
<li>生成托管堆栈跟踪时，调试器将使用该功能。</li>
<li>各种其他方法（通常是那些与某些公共托管API接近的方法）执行堆栈遍历以获取有关其调用者的信息（例如该调用者的方法，类或程序集）。</li>
</ul>
<h2 id="CLR在哪里使用“Stack-Walking”？"><a href="#CLR在哪里使用“Stack-Walking”？" class="headerlink" title="CLR在哪里使用“Stack Walking”？"></a>CLR在哪里使用“Stack Walking”？</h2><p>在深入探讨“内部”之前，让我们看一下运行时在何处利用“堆栈遍历”，以下是完整列表（自.NET Core CLR’Release 2.2’起）。所有这些示例最终都在这里调用该Thread::StackWalkFrames(..)方法，并提供了一个callback在API遇到堆栈的新部分时触发的方法（有关更多信息，请参见下面的“如何使用它”）。</p>
<h4 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h4><ul>
<li>垃圾收集（GC）<ul>
<li>ScanStackRoots(..)</li>
</ul>
</li>
<li>异常处理（unwinding）<ul>
<li>x86-UnwindFrames(..)</li>
<li>x64-ResetThreadAbortState(..)</li>
</ul>
</li>
<li>异常处理（resumption）：<ul>
<li>ExceptionTracker::FindNonvolatileRegisterPointers(..) </li>
<li>ExceptionTracker::RareFindParentStackFrame(..)</li>
</ul>
</li>
<li>线程数：<ul>
<li>Thread::IsRunningIn(..)（AppDomain）</li>
<li>Thread::DetectHandleILStubsForDebugger(..) </li>
</ul>
</li>
<li>线程暂停：<ul>
<li>Thread::IsExecutingWithinCer()（“强制执行区域”）</li>
<li>Thread::HandledJITCase(..)</li>
</ul>
</li>
</ul>
<h4 id="调试-诊断"><a href="#调试-诊断" class="headerlink" title="调试/诊断"></a>调试/诊断</h4><ul>
<li><p>调试器</p>
<ul>
<li>DebuggerWalkStack(..)</li>
<li>DebuggerWalkStackProc() 从调用DebuggerWalkStack(..)</li>
</ul>
</li>
<li><p>托管API（例如 System.Diagnostics.StackTrace）</p>
<ul>
<li>经由托管代码的调用InternalCall（C＃）DebugStackTrace::GetStackFramesInternal(..)（C ++）</li>
<li>在DebugStackTrace::GetStackFramesHelper(..) 结束之前</li>
</ul>
</li>
<li><p>DAC（通过SOS） -扫描GC“根”</p>
<ul>
<li>DacStackReferenceWalker::WalkStack&lt;..&gt;(..)</li>
</ul>
</li>
<li><p>分析API</p>
<ul>
<li>ProfToEEInterfaceImpl::ProfilerStackWalkFramesWrapper(..)</li>
</ul>
</li>
<li><p>事件管道（诊断）</p>
<ul>
<li>EventPipe::WalkManagedStackForThread(..)</li>
</ul>
</li>
<li><p>CLR打印堆栈跟踪（到控制台/日志，仅DEBUG构建）</p>
<ul>
<li>PrintStackTrace()</li>
</ul>
</li>
</ul>
<h4 id="间接调用场景"><a href="#间接调用场景" class="headerlink" title="间接调用场景"></a>间接调用场景</h4><ul>
<li>反射<ul>
<li>RuntimeMethodHandle::GetCurrentMethod(..) 这里（回调）</li>
</ul>
</li>
<li>应用程序（App）域<ul>
<li>SystemDomain::GetCallersMethod(..)（GetCallersType(..)和GetCallersModule(..)）</li>
<li>SystemDomain::GetCallersModule(..) 这里（回调）</li>
</ul>
</li>
<li>“代码投放”<ul>
<li>CheckStacksAndPitch()</li>
</ul>
</li>
<li>可扩展类工厂（System.Runtime.InteropServices.ExtensibleClassFactory）<ul>
<li>RegisterObjectCreationCallback(..) </li>
</ul>
</li>
<li>堆栈采样器（未使用？）<ul>
<li>StackSampler::ThreadProc()</li>
</ul>
</li>
</ul>
<h2 id="堆栈抓取标记"><a href="#堆栈抓取标记" class="headerlink" title="堆栈抓取标记"></a>堆栈抓取标记</h2><p>上述情况之一值得仔细研究，但首先，为什么要使用coreclr / issues /＃21629（注释）中的“堆栈爬网标记” ：</p>
<blockquote>
<p>不幸的是，在netstandard2.0推送过程中添加了很多传统API，它们的行为取决于调用者。调用者基本上作为隐式参数传递给API。这些StackCrawlMark中的大多数都在那里支持这些API。</p>
</blockquote>
<p>因此，我们可以看到CLR本身内的多个功能需要了解其调用者。为了进一步了解这一点，让我们看一个例子GetType(string typeName)。这是从外部可见方法一直到完成工作的流程，请注意StackCrawlMark实例是如何传递的：</p>
<ul>
<li>Type::GetType(string typeName) （创建StackCrawlMark.LookForMyCaller）</li>
<li>RuntimeType::GetType(.., ref StackCrawlMark stackMark) </li>
<li>RuntimeType::GetTypeByName(.., ref StackCrawlMark stackMark, ..) </li>
<li>extern void GetTypeByName(.., ref StackCrawlMark stackMark, ..) 定义（调用本地代码，即[DllImport(JitHelpers.QCall, ..)]）</li>
<li>RuntimeTypeHandle::GetTypeByName(.., QCall::StackCrawlMarkHandle pStackMark, ..) </li>
<li>TypeHandle TypeName::GetTypeManaged(.., StackCrawlMark* pStackMark, ..) </li>
<li>TypeHandle TypeName::GetTypeWorker(.. , StackCrawlMark* pStackMark, ..) </li>
<li>SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark,..) </li>
<li>SystemDomain::GetCallersModule(StackCrawlMark* stackMark, ..) </li>
<li>SystemDomain::CallersMethodCallbackWithStackMark(..)</li>
</ul>
<p>另外，JIT（通过VM）还必须确保所有相关方法在调用堆栈中都可用，即它们不能被删除：</p>
<ul>
<li>防止内联CEEInfo::canInline(..)</li>
<li>防止通过“尾部呼叫”删除CEEInfo::canTailCall(..)</li>
</ul>
<p>但是，该StackCrawlMark功能目前正在清理中，因此将来可能会有所不同：</p>
<ul>
<li>从任务中删除NoInlining / StackCrawlMarks</li>
<li>从GetSatelliteAssembly删除堆栈标记</li>
<li>删除RtFieldInfo中不必要的StackCrawlMarks</li>
<li>避免在调用堆栈中不必要地传递堆栈爬网标记（如上所示示例！）</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>大多数.NET开发人员都会在处理异常时碰到“堆栈跟踪”。我原本打算在这里也描述“异常处理”，但是后来我打开了/src/vm/exceptionhandling.cpp，发现其中包含7,000行以上的代码！因此，我决定可以等待将来的帖子。</p>
<p>但是，如果您想了解有关“内部人员”的更多信息，我真的建议克里斯·布鲁姆（Chris Brumme）发表“异常模型（Exception Model）（2003）”，该主题是该主题的权威指南（另请参见他的Channel9视频），并且与往常一样，“ BotR”一章“每个（运行时）开发人员都需要了解的有关运行时异常的知识非常值得一读。</p>
<p>另外，我建议您看一下“内部异常”演讲中的幻灯片，以及相关的.NET Inside Out Part 2 —亚当·弗曼尼克（Adam Furmanek）编写的C＃中的异常处理和重新抛出。</p>
<h2 id="“堆栈漫游”-API"><a href="#“堆栈漫游”-API" class="headerlink" title="“堆栈漫游” API"></a>“堆栈漫游” API</h2><p>现在，我们已经看到了在那里它的使用，让我们来看看“栈行走” API本身。首先，如何使用？</p>
<h3 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h3><p>值得指出的是，从C＃/ F＃/ VB.NET代码访问它的唯一方法是通过StackTrace 类，只有运行时本身可以Thread::StackWalkFrames(..)直接调用。运行时中最简单的用法是EventPipe::WalkManagedStackForThread(..)（请参阅此处），如下所示。如您所见，在这种情况下ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS，指定相关标志很简单，然后提供回调，该回调在EventPipe类中是StackWalkCallback方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventPipe::WalkManagedStackForThread</span><span class="params">(Thread *pThread, StackContents &amp;stackContents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTRACTL</span><br><span class="line">    &#123;</span><br><span class="line">        NOTHROW;</span><br><span class="line">        GC_NOTRIGGER;</span><br><span class="line">        MODE_ANY;</span><br><span class="line">        PRECONDITION(pThread != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CONTRACTL_END;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Calling into StackWalkFrames in preemptive mode violates the host contract,</span></span><br><span class="line">    <span class="comment">// but this contract is not used on CoreCLR.</span></span><br><span class="line">    CONTRACT_VIOLATION( HostViolation );</span><br><span class="line">​</span><br><span class="line">    stackContents.Reset();</span><br><span class="line">​</span><br><span class="line">    StackWalkAction swaRet = pThread-&gt;StackWalkFrames(</span><br><span class="line">        (PSTACKWALKFRAMESCALLBACK) &amp;StackWalkCallback,</span><br><span class="line">        &amp;stackContents,</span><br><span class="line">        ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> ((swaRet == SWA_DONE) || (swaRet == SWA_CONTINUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StackWalkFrame(..)然后，该函数会在触发如下所示的回调之前进行实际遍历堆栈的繁重工作。在这种情况下，它仅记录“指令指针”（IP / CP）和“托管功能”，这是MethodDesc通过pCf-&gt;GetFunction()调用获得的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StackWalkAction <span class="title">EventPipe::StackWalkCallback</span><span class="params">(CrawlFrame *pCf, StackContents *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CONTRACTL</span><br><span class="line">    &#123;</span><br><span class="line">        NOTHROW;</span><br><span class="line">        GC_NOTRIGGER;</span><br><span class="line">        MODE_ANY;</span><br><span class="line">        PRECONDITION(pCf != <span class="literal">NULL</span>);</span><br><span class="line">        PRECONDITION(pData != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CONTRACTL_END;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Get the IP.</span></span><br><span class="line">    UINT_PTR controlPC = (UINT_PTR)pCf-&gt;GetRegisterSet()-&gt;ControlPC;</span><br><span class="line">    <span class="keyword">if</span> (controlPC == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pData-&gt;GetLength() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This happens for pinvoke stubs on the top of the stack.</span></span><br><span class="line">            <span class="keyword">return</span> SWA_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    _ASSERTE(controlPC != <span class="number">0</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Add the IP to the captured stack.</span></span><br><span class="line">    pData-&gt;Append(controlPC, pCf-&gt;GetFunction());</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// Continue the stack walk.</span></span><br><span class="line">    <span class="keyword">return</span> SWA_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="这个怎么运作"><a href="#这个怎么运作" class="headerlink" title="这个怎么运作"></a>这个怎么运作</h3><p>现在到最有趣的部分，如何运行时实际上遍历了堆栈。好吧，首先让我们从“ BotR”页面了解堆栈的外观：</p>
<p><img src="../../static/images/17af7fd01c668a3fffbdebf1713d5c065bc765dfcf431c70ee905c4835186046.png" alt="Stack Description from BotR"></p>
<p>要注意的主要事情是.NET“堆栈”可以包含3种类型的方法：</p>
<ul>
<li>托管-表示从C＃/ F＃/ VB.NET开始的代码，已转换为IL，然后最终由“ JIT编译器”编译为本机代码。</li>
<li>非托管-在运行时之外存在的完全本机代码，即运行时调用的OS函数或通过调用的用户函数P/Invoke。运行时只关心过渡到或超出常规的非托管代码，是不关心其中的堆栈帧。</li>
<li>运行时托管-仍是本机代码，但这有所不同，因为运行时案例更多关于此代码。例如，基本类库中有很多部分使用InternalCall方法，有关更多信息，请参见后面的“帮助器方法”框架部分。</li>
</ul>
<p>因此，“堆栈遍历”在进行过程中必须处理这些不同的情况。现在让我们看一下从入口点方法开始的“代码流” StackWalkFrames(..)：</p>
<ul>
<li>Thread::StackWalkFrames(..) 这里</li>
<li>入口点功能，通过这些标志可以控制“栈游走”的类型</li>
<li>Thread::StackWalkFramesEx(..) 这里</li>
<li>StackFrameIterator通过调用here设置的worker函数StackFrameIterator::Init(..)</li>
<li>StackFrameIterator::Next() 在这里，然后放手给初级工人的方法+</li>
<li>StackFrameIterator::NextRaw() 在这里，做5件事情：<ul>
<li>EEJitManager::JitCodeToMethodInfo(..) 在这里，它使用了一个看起来很酷的数据结构，称为“半字节映射”</li>
<li>NativeImageJitManager::JitCodeToMethodInfo(..)</li>
<li>ReadyToRunJitManager::JitCodeToMethodInfo(..)</li>
<li>x64-Thread::VirtualUnwindCallFrame(..) 在这里，然后VirtualUnwindNonLeafCallFrame(..) 在这里或VirtualUnwindLeafCallFrame(..) 这里打电话。所有这些函数都利用Windows API函数 RtlLookupFunctionEntry(..)进行实际的展开。</li>
<li>x86-::UnwindStackFrame(..) 在这里，依次UnwindEpilog(..) 在这里和UnwindEspFrame(..) 这里打电话。不同于x64，在x86所有CRL代码中，所有的“堆栈展开”都是手动完成的。<ul>
<li>CheckForSkippedFrames(..) 在这里，处理可能已在托管堆栈帧中分配的帧（例如，内联的p / invoke调用）。</li>
<li>UnwindStackFrame(..) 在这里，依次致电：</li>
<li>PostProcessingForManagedFrames(..) 在这里，确定堆栈遍历实际上是否在托管方法内，而不是在本机框架内。</li>
<li>ProcessIp(..) 这是根据当前指令指针（IP）查找当前托管方法（如果有）的工作。它通过调用到 这里，然后以以下其中一种方式结束： EECodeInfo::Init(..)</li>
<li>ProcessCurrentFrame(..) 在这里，做一些最后的整理和整理。</li>
</ul>
</li>
</ul>
</li>
<li>CrawlFrame::GotoNextFrame() 这里<ul>
<li>在pFrame-&gt;Next() 这里依次调用以遍历驱动“堆栈遍历”的框架的“链接列表”（稍后在这些“框架”中详细介绍）</li>
</ul>
</li>
<li>StackFrameIterator::Filter() 这里<ul>
<li>本质上，这是一个处理所有不同框架状态并决定是否应继续执行“堆栈遍历”的巨大switch声明。</li>
</ul>
</li>
</ul>
<p>时，它得到一个有效的帧它触发回调在Thread::MakeStackwalkerCallback(..) 这里和在经过一个指向当前CrawlFrame类这里定义，这暴露的方法，如IsFrameless()，GetFunction()和GetThisPointer()。该CrawlFrame实际上代表2分的情况，基于当前的IP：</p>
<ul>
<li>由此处定义的Frame类表示的本机代码，我们将在稍后讨论。</li>
<li>托管代码，从技术上讲就是“本地代码”的“托管代码”，因此更准确地说是托管堆栈框架。在这种情况下，将提供此处定义的MethodDesc类，您可以在相应的BotR章中阅读有关此关键CLR数据结构的更多信息。</li>
</ul>
<h3 id="看到它在行动"><a href="#看到它在行动" class="headerlink" title="看到它在行动"></a>看到它在行动</h3><p>幸运的是，我们能够在CLR（COMPLUS_LogEnable，COMPLUS_LogToFile＆COMPLUS_LogFacility）的调试版本中打开一些不错的诊断程序。有了适当的代码后，给出如下C＃代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodA();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MethodC();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MethodImpl(MethodImplOptions.NoInlining)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodC</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stackTrace = <span class="keyword">new</span> StackTrace(fNeedFileInfo: <span class="literal">true</span>);</span><br><span class="line">        Console.WriteLine(stackTrace.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们得到如下所示的输出，您可以在其中看到“堆栈行走”过程。它开始于InitializeSourceInfo和CaptureStackTrace它们内部的方法StackTrace类（见这里），向上移动堆栈前MethodC- &gt; MethodB- &gt; MethodA，最后停止在Main函数。在实际展开之前，它会执行“ FILTER”和“ CONSIDER”步骤（“完成……结束”）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TID 4740: STACKWALK    starting with partial context</span><br><span class="line">TID 4740: STACKWALK: [000] FILTER  : EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [001] CONSIDER: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [001] FILTER  : EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cc48  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [002] CONSIDER: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cdd8  vtbl&#x3D; 00007ffd&#96;74995220 </span><br><span class="line">TID 4740: STACKWALK    LazyMachState::unwindLazyState(ip:00007FFD7439C45C,sp:000000029977C338)</span><br><span class="line">TID 4740: STACKWALK: [002] CALLBACK: EXPLICIT : PC&#x3D; 00000000&#96;00000000  SP&#x3D; 00000000&#96;00000000  Frame&#x3D; 00000002&#96;9977cdd8  vtbl&#x3D; 00007ffd&#96;74995220 </span><br><span class="line">TID 4740: STACKWALK    HelperMethodFrame::UpdateRegDisplay cached ip:00007FFD72FE9258, sp:000000029977D300</span><br><span class="line">TID 4740: STACKWALK: [003] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72fe9258  SP&#x3D; 00000002&#96;9977d300  method&#x3D;InitializeSourceInfo </span><br><span class="line">TID 4740: STACKWALK: [003] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72fe9258  SP&#x3D; 00000002&#96;9977d300  method&#x3D;InitializeSourceInfo </span><br><span class="line">TID 4740: STACKWALK: [004] about to unwind for &#39;InitializeSourceInfo&#39;, SP: 00000002&#96;9977d300 , IP: 00007ffd&#96;72fe9258 </span><br><span class="line">TID 4740: STACKWALK: [004] finished unwind for &#39;InitializeSourceInfo&#39;, SP: 00000002&#96;9977d480 , IP: 00007ffd&#96;72eeb671 </span><br><span class="line">TID 4740: STACKWALK: [004] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeb671  SP&#x3D; 00000002&#96;9977d480  method&#x3D;CaptureStackTrace </span><br><span class="line">TID 4740: STACKWALK: [004] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeb671  SP&#x3D; 00000002&#96;9977d480  method&#x3D;CaptureStackTrace </span><br><span class="line">TID 4740: STACKWALK: [005] about to unwind for &#39;CaptureStackTrace&#39;, SP: 00000002&#96;9977d480 , IP: 00007ffd&#96;72eeb671 </span><br><span class="line">TID 4740: STACKWALK: [005] finished unwind for &#39;CaptureStackTrace&#39;, SP: 00000002&#96;9977d5b0 , IP: 00007ffd&#96;72eeadd0 </span><br><span class="line">TID 4740: STACKWALK: [005] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeadd0  SP&#x3D; 00000002&#96;9977d5b0  method&#x3D;.ctor </span><br><span class="line">TID 4740: STACKWALK: [005] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;72eeadd0  SP&#x3D; 00000002&#96;9977d5b0  method&#x3D;.ctor </span><br><span class="line">TID 4740: STACKWALK: [006] about to unwind for &#39;.ctor&#39;, SP: 00000002&#96;9977d5b0 , IP: 00007ffd&#96;72eeadd0 </span><br><span class="line">TID 4740: STACKWALK: [006] finished unwind for &#39;.ctor&#39;, SP: 00000002&#96;9977d5f0 , IP: 00007ffd&#96;14c620d3 </span><br><span class="line">TID 4740: STACKWALK: [006] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c620d3  SP&#x3D; 00000002&#96;9977d5f0  method&#x3D;MethodC </span><br><span class="line">TID 4740: STACKWALK: [006] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c620d3  SP&#x3D; 00000002&#96;9977d5f0  method&#x3D;MethodC </span><br><span class="line">TID 4740: STACKWALK: [007] about to unwind for &#39;MethodC&#39;, SP: 00000002&#96;9977d5f0 , IP: 00007ffd&#96;14c620d3 </span><br><span class="line">TID 4740: STACKWALK: [007] finished unwind for &#39;MethodC&#39;, SP: 00000002&#96;9977d630 , IP: 00007ffd&#96;14c62066 </span><br><span class="line">TID 4740: STACKWALK: [007] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62066  SP&#x3D; 00000002&#96;9977d630  method&#x3D;MethodB </span><br><span class="line">TID 4740: STACKWALK: [007] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62066  SP&#x3D; 00000002&#96;9977d630  method&#x3D;MethodB </span><br><span class="line">TID 4740: STACKWALK: [008] about to unwind for &#39;MethodB&#39;, SP: 00000002&#96;9977d630 , IP: 00007ffd&#96;14c62066 </span><br><span class="line">TID 4740: STACKWALK: [008] finished unwind for &#39;MethodB&#39;, SP: 00000002&#96;9977d660 , IP: 00007ffd&#96;14c62016 </span><br><span class="line">TID 4740: STACKWALK: [008] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62016  SP&#x3D; 00000002&#96;9977d660  method&#x3D;MethodA </span><br><span class="line">TID 4740: STACKWALK: [008] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c62016  SP&#x3D; 00000002&#96;9977d660  method&#x3D;MethodA </span><br><span class="line">TID 4740: STACKWALK: [009] about to unwind for &#39;MethodA&#39;, SP: 00000002&#96;9977d660 , IP: 00007ffd&#96;14c62016 </span><br><span class="line">TID 4740: STACKWALK: [009] finished unwind for &#39;MethodA&#39;, SP: 00000002&#96;9977d690 , IP: 00007ffd&#96;14c61f65 </span><br><span class="line">TID 4740: STACKWALK: [009] CONSIDER: FRAMELESS: PC&#x3D; 00007ffd&#96;14c61f65  SP&#x3D; 00000002&#96;9977d690  method&#x3D;Main </span><br><span class="line">TID 4740: STACKWALK: [009] CALLBACK: FRAMELESS: PC&#x3D; 00007ffd&#96;14c61f65  SP&#x3D; 00000002&#96;9977d690  method&#x3D;Main </span><br><span class="line">TID 4740: STACKWALK: [00a] about to unwind for &#39;Main&#39;, SP: 00000002&#96;9977d690 , IP: 00007ffd&#96;14c61f65 </span><br><span class="line">TID 4740: STACKWALK: [00a] finished unwind for &#39;Main&#39;, SP: 00000002&#96;9977d6d0 , IP: 00007ffd&#96;742f9073 </span><br><span class="line">TID 4740: STACKWALK: [00a] FILTER  : NATIVE   : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0 </span><br><span class="line">TID 4740: STACKWALK: [00b] CONSIDER: EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977de58  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00b] FILTER  : EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977de58  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00c] CONSIDER: EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977e7e0  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: [00c] FILTER  : EXPLICIT : PC&#x3D; 00007ffd&#96;742f9073  SP&#x3D; 00000002&#96;9977d6d0  Frame&#x3D; 00000002&#96;9977e7e0  vtbl&#x3D; 00007ffd&#96;74a105b0 </span><br><span class="line">TID 4740: STACKWALK: SWA_DONE: reached the end of the stack</span><br></pre></td></tr></table></figure>
<p>要了解更多信息，可以在\vm\stackwalk.cpp中搜索这些诊断消息，例如在Thread::DebugLogStackWalkInfo(..) 此处</p>
<h2 id="展开“本地”代码"><a href="#展开“本地”代码" class="headerlink" title="展开“本地”代码"></a>展开“本地”代码</h2><p>如这篇出色的文章所述：</p>
<blockquote>
<p>从根本上讲，有两种主要方法可以在ABI（应用程序二进制接口）中实现异常传播：</p>
<ul>
<li>“动态注册”，在每个激活记录中带有框架指针，并组织为一个链表。这使得堆栈快速展开，但以必须在调用其他函数的每个函数中设置帧指针为代价。这也更容易实现。</li>
<li>“表驱动”，其中编译器和汇编器在程序代码旁边创建数据结构，以指示哪些代码地址对应于哪些激活记录大小。在例如GNU工具链中，这称为“呼叫帧信息”（CFI）数据。生成异常时，将加载此表中的数据以确定如何展开。这使得异常传播较慢，但一般情况下较快。</li>
</ul>
</blockquote>
<p>事实证明，.NET使用“表驱动”方法，原因在“ BotR”中进行了解释：</p>
<blockquote>
<p>框架的确切定义因平台而异，并且在许多平台上，并没有硬性定义所有功能都遵循的框架格式（x86就是一个示例）。相反，编译器通常可以自由地优化帧的确切格式。在此类系统上，无法保证stackwalk将返回100％正确或完整的结果（出于调试目的，使用诸如pdbs之类的调试符号来填补空白，以便调试器可以生成更准确的堆栈跟踪）。</p>
</blockquote>
<blockquote>
<p>对于CLR，这不是问题，因为我们不需要完全通用的堆栈遍历。取而代之的是，我们只对那些受管理的框架（即代表托管方法）感兴趣，或者在某种程度上，这些框架来自用于实现部分运行时本身的非托管代码。特别是，除了说明此类帧在何处过渡到运行时本身或从运行时本身过渡（即我们关心的帧类型之一）的位置外，不能保证第三方非托管帧的保真度。</p>
</blockquote>
<h2 id="镜框"><a href="#镜框" class="headerlink" title="镜框"></a>镜框</h2><p>为了启用本机代码的“展开”或更严格地实现本机代码的“进入”和“退出”转换，CLR使用的机制Frames，该机制在此处的源代码中定义。这些框架排列成层次结构Frame，每种情况都有一种类型，有关这些个体的更多信息，Frames请在此处查看出色的源代码注释。</p>
<ul>
<li>框架（抽象/基类）<ul>
<li>ComMethodFrame</li>
<li>UMThkCallFrame</li>
<li>ComPrestubMethodFrame</li>
<li>StubHelperFrame</li>
<li>SecureDelegateFrame</li>
<li>FramedMethodFrame</li>
<li>组播帧</li>
<li>ComPlusMethodFrame</li>
<li>PInvokeCalliFrame</li>
<li>PrestubMethodFrame</li>
<li>StubDispatchFrame</li>
<li>外部方法框架</li>
<li>TPMethodFrame</li>
<li>HelperMethodFrame_1OBJ</li>
<li>HelperMethodFrame_2OBJ</li>
<li>HelperMethodFrame_3OBJ</li>
<li>HelperMethodFrame_PROTECTOBJ</li>
<li>RedirectedThreadFrame</li>
<li>GC框架</li>
<li>FaultingExceptionFrame</li>
<li>HijackFrame</li>
<li>可恢复帧</li>
<li>InlinedCallFrame</li>
<li>HelperMethodFrame</li>
<li>TransitionFrame</li>
<li>UnmanagedToManagedFrame</li>
<li>ContextTransitionFrame</li>
<li>尾叫帧</li>
<li>ProtectByRefsFrame</li>
<li>ProtectValueClassFrame</li>
<li>调试器类InitMarkFrame</li>
<li>DebuggerSecurityCodeMarkFrame</li>
<li>调试器退出框架</li>
<li>调试器U2MCatchHandlerFrame</li>
<li>FuncEvalFrame</li>
<li>ExceptionFilterFrame</li>
</ul>
</li>
</ul>
<h2 id="“帮助方法”框架"><a href="#“帮助方法”框架" class="headerlink" title="“帮助方法”框架"></a>“帮助方法”框架</h2><p>但是，为了理解这一点，让我们看一种Frame称为的HelperMethodFrame（上）。当运行时的.NET代码调用C ++代码进行繁重的操作时（通常出于性能原因），将使用此功能。一个示例是，如果您Environment.GetCommandLineArgs()最终以该代码（C＃）进行调用，但请注意，它最终会调用extern标记为的方法InternalCall：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">string</span>[] <span class="title">GetCommandLineArgsNative</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这意味着，该方法的其余部分在C ++运行时实现，你可以看到方法调用是如何有线了，结束了之前SystemNative::GetCommandLineArgs 在这里其如下所示，：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FCIMPL0(Object*, SystemNative::GetCommandLineArgs)</span><br><span class="line">&#123;</span><br><span class="line">    FCALL_CONTRACT;</span><br><span class="line"></span><br><span class="line">    PTRARRAYREF strArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    HELPER_METHOD_FRAME_BEGIN_RET_1(strArray); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; started here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error handling and setup code removed for clarity</span></span><br><span class="line"></span><br><span class="line">    strArray = (PTRARRAYREF) AllocateObjectArray(numArgs, g_pStringClass);</span><br><span class="line">    <span class="comment">// Copy each argument into new Strings.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numArgs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        STRINGREF str = StringObject::NewString(argv[i]);</span><br><span class="line">        STRINGREF * destData = ((STRINGREF*)(strArray-&gt;GetDataPtr())) + i;</span><br><span class="line">        SetObjectReference((OBJECTREF*)destData, (OBJECTREF)str, strArray-&gt;GetAppDomain());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] argv;</span><br><span class="line"></span><br><span class="line">    HELPER_METHOD_FRAME_END(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; ended/closed here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OBJECTREFToObject(strArray);</span><br><span class="line">&#125;</span><br><span class="line">FCIMPLEND</span><br></pre></td></tr></table></figure>
<p>注意：此代码大量使用了宏，有关原始代码和扩展版本（发布和调试），请参见本要点。此外，如果您想了解有关这些神秘物品FCalls（以及相关的物品QCalls）的更多信息，请参见Mscorlib和“ BotR”中的“调用运行时”。</p>
<p>但是在代码示例中要看的主要是HELPER_METHOD_FRAME_BEGIN_RET_1()宏，最终安装了HelperMethodFrame_1OBJ类的实例。宏扩展为如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FrameWithCookie &lt; HelperMethodFrame_1OBJ &gt; __helperframe(__me, Frame::FRAME_ATTR_NONE, (OBJECTREF * ) &amp; strArray); </span><br><span class="line">&#123;</span><br><span class="line">  __helperframe.Push(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; pushed</span></span><br><span class="line"></span><br><span class="line">  Thread * CURRENT_THREAD = __helperframe.GetThread();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> CURRENT_THREAD_AVAILABLE = <span class="literal">true</span>;</span><br><span class="line">  (<span class="keyword">void</span>) CURRENT_THREAD_AVAILABLE;; &#123;</span><br><span class="line">	Exception * __pUnCException = <span class="number">0</span>;</span><br><span class="line">	Frame * __pUnCEntryFrame = ( &amp; __helperframe);</span><br><span class="line">	<span class="keyword">bool</span> __fExceptionCatched = <span class="literal">false</span>;;</span><br><span class="line">	<span class="keyword">try</span> &#123;;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// Original code from SystemNative::GetCommandLineArgs goes in here</span></span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception * __pException) &#123;;</span><br><span class="line">	  <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">	  __pUnCException = __pException;</span><br><span class="line">	  UnwindAndContinueRethrowHelperInsideCatch(__pUnCEntryFrame, __pUnCException);</span><br><span class="line">	  __fExceptionCatched = <span class="literal">true</span>;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (__fExceptionCatched) &#123;;</span><br><span class="line">	  UnwindAndContinueRethrowHelperAfterCatch(__pUnCEntryFrame, __pUnCException);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __helperframe.Pop(); <span class="comment">// &lt;-- &#x27;Helper method Frame&#x27; popped</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：Push()和Pop()相对_helperMethodFrame应，可用于“堆栈行走”。您还可以看到CLR放置的try/catch块，以确保将本机代码中的任何异常转换为C＃/ F＃/ VB.NET代码可以处理的托管异常。如果您有兴趣，可以在此摘要中找到完整的宏扩展。</p>
<p>因此，总而言之，当调用本机代码时，它们Frames会被推送到“链接列表”上，而从本机代码返回时，它们会从列表中弹出。这意味着“链接列表”随时都包含所有当前或活动列表Frames。</p>
<h2 id="本机放松信息"><a href="#本机放松信息" class="headerlink" title="本机放松信息"></a>本机放松信息</h2><p>除了创建“框架”之外，CLR还确保C ++编译器为本地代码发出“展开信息”。如果我们使用DUMPBIN工具并运行，我们可以看到这一点dumpbin /UNWINDINFO coreclr.dll。我们得到以下输出SystemNative::GetCommandLineArgs(..)（之前已经看过）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0002F064 003789B0 00378B7E 004ED1D8  ?GetCommandLineArgs@SystemNative@@SAPEAVObject@@XZ (public: static class Object * __cdecl SystemNative::GetCommandLineArgs(void))</span><br><span class="line">  Unwind version: 1</span><br><span class="line">  Unwind flags: EHANDLER UHANDLER</span><br><span class="line">  Size of prologue: 0x3B</span><br><span class="line">  Count of codes: 13</span><br><span class="line">  Unwind codes:</span><br><span class="line">    29: SAVE_NONVOL, register&#x3D;r12 offset&#x3D;0x1C8</span><br><span class="line">    25: SAVE_NONVOL, register&#x3D;rdi offset&#x3D;0x1C0</span><br><span class="line">    21: SAVE_NONVOL, register&#x3D;rsi offset&#x3D;0x1B8</span><br><span class="line">    1D: SAVE_NONVOL, register&#x3D;rbx offset&#x3D;0x1B0</span><br><span class="line">    10: ALLOC_LARGE, size&#x3D;0x190</span><br><span class="line">    09: PUSH_NONVOL, register&#x3D;r15</span><br><span class="line">    07: PUSH_NONVOL, register&#x3D;r14</span><br><span class="line">    05: PUSH_NONVOL, register&#x3D;r13</span><br><span class="line">  Handler: 00148F14 __GSHandlerCheck_EH</span><br><span class="line">  EH Handler Data: 00415990</span><br><span class="line">  GS Unwind flags: EHandler UHandler</span><br><span class="line">  Cookie Offset: 00000180</span><br><span class="line"></span><br><span class="line">0002F070 00378B7E 00378BB4 004ED26C</span><br><span class="line">  Unwind version: 1</span><br><span class="line">  Unwind flags: EHANDLER UHANDLER</span><br><span class="line">  Size of prologue: 0x0A</span><br><span class="line">  Count of codes: 2</span><br><span class="line">  Unwind codes:</span><br><span class="line">    0A: ALLOC_SMALL, size&#x3D;0x20</span><br><span class="line">    06: PUSH_NONVOL, register&#x3D;rbp</span><br><span class="line">  Handler: 0014978C __CxxFrameHandler3</span><br><span class="line">  EH Handler Data: 00415990</span><br></pre></td></tr></table></figure>
<p>如果您想了解此处的更多信息，我真的建议您阅读出色的文章x64手动堆栈重建和堆栈遍历。但实质上，“展开信息”描述了方法中使用的寄存器以及该方法的堆栈数。这些信息足以告诉运行时如何在堆栈中“展开”该特定方法。</p>
<h2 id="Windows和Unix之间的差异"><a href="#Windows和Unix之间的差异" class="headerlink" title="Windows和Unix之间的差异"></a>Windows和Unix之间的差异</h2><p>但是，更复杂的是，“本机代码展开”对“ Windows”和“ Unix”使用了不同的机制，如coreclr / issues /＃177（注释）所述：</p>
<blockquote>
<ul>
<li>用于管理代码的堆栈遍历器。JIT将生成常规的Windows样式展开信息。我们将重用当前已检入的Windows展开器代码中的调试器组件，以展开Linux / Mac上托管代码中的调用。不幸的是，这项工作需要对运行时进行更改，而这些更改目前无法在CoreCLR存储库中进行测试，因此现在很难在公开场合进行。但是我们正在努力解决这一问题，因为正如我在开始时提到的那样，我们的目标是在公众中开展大多数工作。</li>
<li>适用于本机代码的Stack Walker。在这里，除了其他所有内容外，我们还需要允许GC释放当前进程中任何线程的本机堆栈，直到找到托管帧为止。当前，我们正在考虑使用libunwind（<a target="_blank" rel="noopener" href="http://www.nongnu.org/libunwind%EF%BC%89%E9%87%8A%E6%94%BE%E6%9C%AC%E6%9C%BA%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E3%80%82@janvorli%E5%81%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E9%AA%8C%EF%BC%8C%E4%BC%BC%E4%B9%8E%E5%8F%AF%E4%BB%A5%E6%BB%A1%E8%B6%B3%E6%88%91%E4%BB%AC%E7%9A%84%E9%9C%80%E6%B1%82%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E6%9C%89%E4%BD%BF%E7%94%A8%E6%AD%A4%E5%BA%93%E7%9A%84%E4%BB%BB%E4%BD%95%E7%BB%8F%E9%AA%8C%E6%88%96%E6%9C%89%E4%BB%BB%E4%BD%95%E6%84%8F%E8%A7%81/%E5%BB%BA%E8%AE%AE%EF%BC%8C%E8%AF%B7%E5%91%8A%E8%AF%89%E6%88%91%E4%BB%AC%E3%80%82">http://www.nongnu.org/libunwind）释放本机调用堆栈。@janvorli做过一些原型设计/实验，似乎可以满足我们的需求。如果您有使用此库的任何经验或有任何意见/建议，请告诉我们。</a></li>
</ul>
</blockquote>
<p>这还表明，对于“托管”或“本机”代码有两种不同的“展开”机制，我们将讨论“展开“ JITted”代码中的“用于托管代码的堆栈行进器”如何工作。</p>
<p>在coreclr / issues /＃177（注释）中也有更多信息：</p>
<blockquote>
<p>我的当前工作分为两部分，正如@ sergiy-k已经提到的那样。在windows风格开卷将被用于实时编译的代码和Unix的开卷本地代码使用的libunwind的低级别unw_xxxx的功能，如unw_step等。</p>
</blockquote>
<p>因此，对于“本机代码”，运行时使用特定于操作系统的机制，即在Unix上使用开源的“ libunwind”库。您可以在下面的代码（从这里开始）中看到不同之处，在Windows Thread::VirtualUnwindCallFrame(..)（实现）下被调用，但是在Unix（即FEATURE_PAL）PAL_VirtualUnwind(..)（实现）上被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FEATURE_PAL</span></span><br><span class="line">    pvControlPc = Thread::VirtualUnwindCallFrame(&amp;ctx, &amp;nonVolRegPtrs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// !FEATURE_PAL</span></span></span><br><span class="line">    ...</span><br><span class="line">    BOOL success = PAL_VirtualUnwind(&amp;ctx, &amp;nonVolRegPtrs);</span><br><span class="line">    ...</span><br><span class="line">    pvControlPc = GetIP(&amp;ctx);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !FEATURE_PAL</span></span></span><br></pre></td></tr></table></figure>
<p>在进一步介绍之前，这里有一些指向.NET Core CLR移植到Linux时为支持“堆栈移动”所做的工作的链接：</p>
<ul>
<li>[x86 / Linux]支持简单异常捕获</li>
<li>[ARM / Linux] coreclr因libunwind＃6698中缺少DWARF功能而失败</li>
<li>修改Windows amd64展开器，使其在Uni…上作为固定代码展开器工作＃259</li>
<li>重构libunwind以在OSX上工作＃284</li>
<li>重新实现PAL＃308的本机异常处理</li>
<li>将Windows展开器代码移出debug文件夹。</li>
<li>.NET核心依赖项（包括“ libunwind”）</li>
<li>sos“ ClrStack”命令现在可以使用</li>
</ul>
<h2 id="展开“-JITted”代码"><a href="#展开“-JITted”代码" class="headerlink" title="展开“ JITted”代码"></a>展开“ JITted”代码</h2><p>最后，我们将研究“托管代码”的情况，即以C＃/ F＃/ VB.NET开始的代码被转换为IL，然后由“ JIT编译器”编译为本地代码。这是您通常希望在“堆栈跟踪”中看到的代码，因为它是您自己编写的代码！</p>
<h3 id="来自“-JIT编译器”的帮助"><a href="#来自“-JIT编译器”的帮助" class="headerlink" title="来自“ JIT编译器”的帮助"></a>来自“ JIT编译器”的帮助</h3><p>简而言之，发生的事情是，当代码被“ JITted”时，编译器还会发出一些额外的信息，这些信息通过在此处EECodeInfo定义的类存储。另见“开卷信息”部分中的JIT编译器&lt; - &gt;运行界面，注意它是如何拥有单独的章节，，和。TARGET_ARMTARGET_ARM64TARGET_X86TARGET_UNIX</p>
<p>另外，CodeGen::genFnProlog() 这里的JIT发出一个函数“序言”，其中包含一些与“展开”相关的数据。这也imlemented在CEEJitInfo::allocUnwindInfo(..)在这一段代码，其表现不同对每个CPU架构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_TARGET_X86_)</span></span><br><span class="line">    <span class="comment">// Do NOTHING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_AMD64_)</span></span><br><span class="line">    pUnwindInfo-&gt;Flags = UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER;</span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)ALIGN_UP(&amp;(pUnwindInfo-&gt;UnwindCode[pUnwindInfo-&gt;CountOfUnwindCodes]), <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_ARM64_)</span></span><br><span class="line">    *(LONG *)pUnwindInfo |= (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); <span class="comment">// X bit</span></span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, <span class="keyword">sizeof</span>(ULONG)));</span><br><span class="line">    *pPersonalityRoutine = ExecutionManager::GetCLRPersonalityRoutineValue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_TARGET_ARM_)</span></span><br><span class="line">    *(LONG *)pUnwindInfo |= (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); <span class="comment">// X bit</span></span><br><span class="line">    ULONG * pPersonalityRoutine = (ULONG*)((BYTE *)pUnwindInfo + ALIGN_UP(unwindSize, <span class="keyword">sizeof</span>(ULONG)));</span><br><span class="line">    *pPersonalityRoutine = (TADDR)ProcessCLRException - baseAddress;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>而且，JIT有几种Compiler::unwindXXX(..)方法，所有方法都在每个CPU的源文件中实现：</p>
<ul>
<li>/src/jit/unwind.cpp</li>
<li>/src/jit/unwind arm .cpp</li>
<li>/src/jit/unwind x86 .cpp</li>
<li>/src/jit/unwind amd64 .cpp</li>
<li>/src/jit/unwind arm64 .cpp</li>
</ul>
<p>幸运的是，我们可以要求JIT输出它发出的展开信息，但这仅适用于CLR的调试版本。给定一个像这样的简单方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodB();</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        Console.WriteLine(ex.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用SET COMPlus_JitUnwindDump=MethodA，我们将获得以下输出，其中包含2个“ Unwind Info”部分，一个用于try，另一个用于该catch块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Unwind Info:</span><br><span class="line">  &gt;&gt; Start offset   : 0x000000 (not in unwind data)</span><br><span class="line">  &gt;&gt;   End offset   : 0x00004e (not in unwind data)</span><br><span class="line">  Version           : 1</span><br><span class="line">  Flags             : 0x00</span><br><span class="line">  SizeOfProlog      : 0x07</span><br><span class="line">  CountOfUnwindCodes: 4</span><br><span class="line">  FrameRegister     : none (0)</span><br><span class="line">  FrameOffset       : N&#x2F;A (no FrameRegister) (Value&#x3D;0)</span><br><span class="line">  UnwindCodes       :</span><br><span class="line">    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 11 * 8 + 8 &#x3D; 96 &#x3D; 0x60</span><br><span class="line">    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)</span><br><span class="line">    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)</span><br><span class="line">    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)</span><br><span class="line">Unwind Info:</span><br><span class="line">  &gt;&gt; Start offset   : 0x00004e (not in unwind data)</span><br><span class="line">  &gt;&gt;   End offset   : 0x0000e2 (not in unwind data)</span><br><span class="line">  Version           : 1</span><br><span class="line">  Flags             : 0x00</span><br><span class="line">  SizeOfProlog      : 0x07</span><br><span class="line">  CountOfUnwindCodes: 4</span><br><span class="line">  FrameRegister     : none (0)</span><br><span class="line">  FrameOffset       : N&#x2F;A (no FrameRegister) (Value&#x3D;0)</span><br><span class="line">  UnwindCodes       :</span><br><span class="line">    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 &#x3D; 48 &#x3D; 0x30</span><br><span class="line">    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)</span><br><span class="line">    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)</span><br><span class="line">    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)</span><br></pre></td></tr></table></figure>
<p>然后，按照上面的“如何工作”部分中的说明，在“堆栈遍历”期间查找此“展开信息” 。</p>
<p>因此，下次您遇到“堆栈跟踪”时，请记住，要使之成为可能的工作量很大！！</p>

    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="/img/alipay.jpg"><b>支付宝打赏</b>
            </span>
            
            
        </div>
    </div>
    <p class="reward-tip">
        赞赏是不耍流氓的鼓励
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="https://nenufm.com" target="_blank">留声与视</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/archives/a/" class="next-post btn btn-default" title='使用Flamegraph分析.NET启动时间'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            使用Flamegraph分析.NET启动时间</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<!-- <link rel="stylesheet" href="https://cdn.bootcss.com/gitalk/1.4.1/gitalk.min.css">
<script src="//cdn.bootcss.com/gitalk/1.4.1/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.9.0/js/md5.min.js"></script> -->

<link rel="stylesheet" href="/css/gitalk.min.css">


<script src="/js/gitalk.min.js"></script>


<script src="/js/md5.min.js"></script>

<div id="gitalk-container"></div>
<script type="text/javascript">
var gitalk = new Gitalk({
    // Gitalk配置
    language: "zh-CN",
    clientID: "3b507ca7f3f849c6bd9a",
    clientSecret: "52c481471db065db5273ec5799ae15116272dba1",
    repo: "dorthl.github.io",
    owner: "dorthl",
    admin: ["dorthl"],
    id: md5(location.pathname),
    distractionFreeMode: true
});
gitalk.render('gitalk-container');
</script>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CLR%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E2%80%9CStack-Walking%E2%80%9D%EF%BC%9F"><span class="toc-text">CLR在哪里使用“Stack Walking”？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5"><span class="toc-text">常见情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-%E8%AF%8A%E6%96%AD"><span class="toc-text">调试&#x2F;诊断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">间接调用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%8A%93%E5%8F%96%E6%A0%87%E8%AE%B0"><span class="toc-text">堆栈抓取标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%A0%86%E6%A0%88%E6%BC%AB%E6%B8%B8%E2%80%9D-API"><span class="toc-text">“堆栈漫游” API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="toc-text">如何使用它</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%80%8E%E4%B9%88%E8%BF%90%E4%BD%9C"><span class="toc-text">这个怎么运作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E5%88%B0%E5%AE%83%E5%9C%A8%E8%A1%8C%E5%8A%A8"><span class="toc-text">看到它在行动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E2%80%9C%E6%9C%AC%E5%9C%B0%E2%80%9D%E4%BB%A3%E7%A0%81"><span class="toc-text">展开“本地”代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E6%A1%86"><span class="toc-text">镜框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%B8%AE%E5%8A%A9%E6%96%B9%E6%B3%95%E2%80%9D%E6%A1%86%E6%9E%B6"><span class="toc-text">“帮助方法”框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%9C%BA%E6%94%BE%E6%9D%BE%E4%BF%A1%E6%81%AF"><span class="toc-text">本机放松信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E5%92%8CUnix%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">Windows和Unix之间的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E2%80%9C-JITted%E2%80%9D%E4%BB%A3%E7%A0%81"><span class="toc-text">展开“ JITted”代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA%E2%80%9C-JIT%E7%BC%96%E8%AF%91%E5%99%A8%E2%80%9D%E7%9A%84%E5%B8%AE%E5%8A%A9"><span class="toc-text">来自“ JIT编译器”的帮助</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2021
                        <a href="/">
                            留声与视
                        </a>
                        <a href="//beian.miit.gov.cn/" target="_blank" rel="nofollow">
                                蜀ICP备16022835号-1
                            </a>
                            
                </span>
            </div>
        </div>
    </div>
</div>
    



<script src="/js/app.js"></script>



    
<script src="/js/busuanzi.pure.mini.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a43c82797ca3a67a1c6b2486928306b1";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>





<script>
    (function () {
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
    })();
</script>

</body>
</html>